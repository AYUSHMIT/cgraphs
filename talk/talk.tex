\documentclass[aspectratio=169]{beamer}
\beamertemplatenavigationsymbolsempty{}
\setbeamertemplate{footline}[frame number]
\usepackage[utf8]{inputenc}
\usepackage{bold-extra}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath}

\usepackage{color}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\definecolor{arsenic}{rgb}{0.23, 0.27, 0.29}
\definecolor{darkgreen}{rgb}{0.0, 0.5, 0.0}
\definecolor{darkred}{rgb}{0.5, 0.0, 0.0}
\definecolor{darkblue}{rgb}{0.0, 0.0, 0.5}
\lstdefinelanguage{JavaScript}{
  keywords={break, let, print, case, then, fun, catch, continue, debugger, default, delete, do, else, false, finally, for, function, if, in, instanceof, new, null, return, switch, this, throw, true, try, typeof, var, void, while, with},
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
  ndkeywords={class, export, boolean, throw, implements, import, this, close, send, recv, fork},
  keywordstyle=\color{green}\bfseries,
  ndkeywordstyle=\color{darkgray}\bfseries,
  identifierstyle=\color{black},
  commentstyle=\color{darkgreen}\ttfamily,
  stringstyle=\color{gray}\ttfamily,
  sensitive=true
}

\lstset{
   language=JavaScript,
   extendedchars=true,
   basicstyle=\footnotesize\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   showtabs=false,
   captionpos=b
}

\lstset{language=javascript}
\lstset{basicstyle=\ttfamily}
\lstset{keywordstyle=\color{darkblue}\bfseries}
\lstset{ndkeywordstyle=\color{purple}\bfseries}

\newcommand{\remph}[1] {\textcolor{red}{\textbf{#1}}}
\newcommand{\gemph}[1] {\textcolor{darkgreen}{\textbf{#1}}}

\def\Put(#1,#2)#3{\leavevmode\makebox(0,0){\put(#1,#2){#3}}}

\usepackage{mathpartir}

\title{Deadlock Freedom for Session Types Using Separation Logic}
\author{Jules Jacobs}
\institute{Radboud University Nijmegen
\\ \href{mailto:julesjacobs@gmail.com}{julesjacobs@gmail.com}}
% \date{November 25, 2020}
\date{}



\setbeamersize{text margin left=5mm,text margin right=5mm}

\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usepackage{adjustbox}

\begin{document}

\frame{
  \titlepage{}
  \begin{center}
     Joint work with Robbert Krebbers (RU) and Stephanie Balzer (CMU)
  \end{center}
  % \begin{center}
  %   \Put(220,150){\includegraphics[scale=0.2]{jules.jpg}}
  %   These slides: \href{https://julesjacobs.com/slides/measurezero.pdf}{julesjacobs.com/slides/measurezero.pdf}
  % \end{center}
}

\tikzstyle{thread} = [rectangle, rounded corners, minimum width=1cm, minimum height=0.6cm,text centered, draw=black, fill=red!30]
\tikzstyle{channel} = [circle, text centered, draw=black, fill=blue!30]
\tikzstyle{lock} = [circle, text centered, draw=black, fill=green!30]
\tikzstyle{arrow} = [thick,->,>=stealth]

\begin{frame}[fragile]
  \frametitle{Overview}
  \begin{itemize}
    \item Channels for concurrency
    \item Operational semantics
    \item Session types
    \item Goal of the research project
    \item Typing channel references with separation logic
    \item The connectivity graph
    \item Deadlock freedom
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Channels for concurrency}

  \noindent
  \begin{minipage}[t]{.57\textwidth}
    \textbf{Example:}
    \begin{lstlisting}
let c' = fork(fun c =>
    send(c, 3)
    let k = recv(c)
    if k < 10
      then send(c,"hello")
      else send(c,"hi")
    close(c)
  )
let n = recv(c')
send(c', 2*n)
let msg = recv(c')
close(c')
print(msg)
    \end{lstlisting}
  \end{minipage}\begin{minipage}[t]{.43\textwidth}
  \textbf{Channel operations:}
  \begin{itemize}
    \item \lstinline|let c' = fork(fun c => ...)|
    \item \lstinline|send(c, msg)|
    \item \lstinline|let msg = recv(c)|
    \item \lstinline|close(c)|
  \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operational model}
  \textbf{State of the system: thread pool + channel buffers}
  \bigskip

  \noindent
  \begin{minipage}[t]{.4\textwidth}
    Threads:\medskip

    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (T2) [thread, right of = T1] {T2};
      \node (T3) [thread, right of = T2] {T3};
      \node (T4) [thread, below of = T1] {T4};
      \node (T5) [thread, right of = T4] {T5};
      \node (T6) [thread, right of = T5] {T6};
    \end{tikzpicture}
    }
  \end{minipage}\begin{minipage}[t]{.4\textwidth}
  Channel buffers:\medskip

  \begin{tabular}{ | c | c | c | }
    \hline
    \textbf{channel 0:} & $msg_{01}$, $msg_{02}$, \ldots & $msg_{01}'$, $msg_{02}'$, \ldots \\
    \hline
    \textbf{channel 1:} & $msg_{11}$, $msg_{12}$, \ldots & $msg_{11}'$, $msg_{12}'$, \ldots \\
    \hline
    \textbf{channel 2:} & $msg_{21}$, $msg_{22}$, \ldots & $msg_{21}'$, $msg_{22}'$, \ldots \\
    \hline
  \end{tabular}
  \end{minipage}

  \bigskip
  \remph{There are two buffers per channel!}

  In the program \lstinline|let c' = fork(fun c => ...)|, \\
  one buffer is for the messages from \lstinline|c| to \lstinline|c'|, \\
  and the other is for messages from \lstinline|c'| to \lstinline|c|.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Potential bugs}

  \begin{itemize}
    \item Wrong type of message, e.g. string instead of int \textbf{(type error)}:
    \begin{lstlisting}
      let c' = fork(fun c => send(c,"hi"); ...)
      recv(c') + 3
    \end{lstlisting}
    \item Using a channel after close \textbf{(use-after-free)}:
    \begin{lstlisting}
      close(c); let msg = recv(c)
    \end{lstlisting}
    \item Both sides do a receive \textbf{(deadlock)}:
    \begin{lstlisting}
      let c' = fork(fun c => recv(c); ...)
      recv(c')
    \end{lstlisting}

    \remph{TODO: More examples of deadlock}

    \item Not closing a channel \textbf{(leak)}:
    \begin{lstlisting}
      fork(fun c => recv(c))
    \end{lstlisting}
  \end{itemize}
  \textbf{Ruling out these bugs is tricky:}\\
  \remph{Higher order channels: } \lstinline|let c = fork(...) in send(d,c)| \\
  \remph{Closures that capture channels: } \lstinline|let f = (fun x => ... c ...) in send(d,f)|
\end{frame}

\begin{frame}[fragile]
  \frametitle{Session types (Honda et al. 1998)}
  \gemph{Session types (Honda et al. 1998) are a type system for ruling out these bugs.} \\
  A \gemph{linear} type system: \textbf{variables must be used exactly once.}
  \bigskip

  \noindent
  \begin{minipage}[t]{0.35\textwidth}
  \textbf{Examples:}

  \begin{lstlisting}
let x = ... in
... x ...
  \end{lstlisting}
  \gemph{$\implies$ OK!}

  \begin{lstlisting}
let x = ... in
... x ... x ...
  \end{lstlisting}
  \remph{$\implies$ TYPE ERROR!}

  \begin{lstlisting}
let x = ... in
... (no x) ...
  \end{lstlisting}
  \remph{$\implies$ TYPE ERROR!}
  \end{minipage}\begin{minipage}[t]{0.65\textwidth}
  \textbf{Send and receive must use functional style:}
  \begin{lstlisting}
let c2 = send(c1,msg)
let (c3,msg) = recv(c2)
close(c3)
  \end{lstlisting}
  Close is \textbf{required} to get rid of variable \lstinline|c3|!

  \bigskip
  \gemph{Rules out 2 of 4 potential bugs immediately:}
  \begin{itemize}
    \item Not closing a channel (leak) \\
    Because variable \lstinline|c3| \textbf{must} be used.
    \item Using a channel after close (use-after-free) \\
    Because the use \lstinline|close(c3)| \textbf{consumes} variable \lstinline|c3|.
  \end{itemize}
  \end{minipage}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Session types: \textbf{channel protocols}}
  \textbf{Example:} \lstinline|!Int, ?Bool, !String, End| \\
  \textbf{Means:} first send an \lstinline|Int|, then receive a \lstinline|Bool|, then send a \lstinline|String|, then close the chanel.

  \begin{lstlisting}[frame=single]
 send : (!A,R) x A -> R      fork[R] : (dual(R) -> Unit) -> R
 recv : (?A,R) -> R x A      close : End -> Unit
  \end{lstlisting}
  \begin{lstlisting}
    let c1 = fork[!Int, ?Bool, !String, End](fun c1' => ...)
      // c1  : !Int, ?Bool, !String, End
      // c1' : ?Int, !Bool, ?String, End
    let c2 = send(c1,3)
      // c2 : ?Bool, !String, End
    let (c3,b) = recv(c2)
      // c3 : !String, End
    let c4 = send(c3, "hello")
      // c4 : End
    close(c4)
  \end{lstlisting}
  \gemph{Rules out local deadlocks (both sides try to receive)}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Features \& Extensions}

  \gemph{Closures \& higher order channels:}
  \begin{lstlisting}
  ?(!String, ?Int, End), !(Bool -> Int), End
  \end{lstlisting}

  \gemph{Recursive channel protocols:}
  \begin{lstlisting}
  T = ?Int, !String, T
  \end{lstlisting}

  \gemph{Choice in channel protocols:}
  \begin{lstlisting}
  T = (?Int, !String, End) + (!Bool, ?Int, End)
  \end{lstlisting}

  \gemph{Dependent channel protocols:}
  \begin{lstlisting}
  T = ?(i:Int) if i < 10 then (!String, End) else (?Bool, End)
  \end{lstlisting}

  \gemph{Asynchronous subtyping:}
  \begin{lstlisting}
  (?Bool, !Int, R) <: (!Int, ?Bool, R)
  \end{lstlisting}

  \gemph{Shared channels:} controlled non-linear usage of channels protected by locks.
  \begin{lstlisting}
  let l = newlock(c)
  let d = fork(fun d' => ... l ...) in ... l ...
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Research goal (ongoing research)}

  \textbf{Session types rule out:}
  \begin{itemize}
    \item \gemph{Type errors}
    \item \gemph{Use-after-free}
    \item \gemph{Leaks}
    \item \remph{Deadlocks?}
    \gemph{Session types do rule out all deadlocks!} (Honda et al. 1998)
  \end{itemize}
  \bigskip

  \textbf{Our goal:} a proof of these 4 properties,
  \begin{itemize}
    \item Mechanised proof in Coq
    \item For a low-level operational semantics with buffers
    \item Reasoning about channel ownership at a high level using separation logic
    \item Supporting both locks and channels using \textbf{connectivity graphs}
  \end{itemize}

  \bigskip
  \textbf{Rest of the talk: \\ (1) What the formal statement of the theorems is like \\(2) High level overview of the proof: separation logic \& connectivity graph}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operational semantics (1)}
  \begin{itemize}
    \item \textbf{State of the system:} $\text{state} = \overbrace{\text{list expr}}^\text{threads} \times
        (\overbrace{\mathbb{N} \times \text{Bool} \to_\text{fin}  \text{list val}}^\text{buffers})$
    \item \textbf{Grammar of expressions:}\begin{equation*}
      \begin{split}
      \text{expr}  ::= & \text{ val} \\
        | & \text{ expr + expr} \\
        | & \text{ let x = expr in expr} \\
        | & \text{ \gemph{send(expr, expr)}} \\
        | & \text{ \gemph{recv(expr, expr)}} \\
        | & \text{ \gemph{fork(expr)}} \\
        | & \text{ \gemph{close(expr)}} \\
        | & \text{ }\dots \\
      \end{split}
      \end{equation*}
  \item \textbf{Values: }
    \(\text{val}  ::=  \text{ n:nat } | \text{ (val, val) } | \text{ fun x $\implies$ expr }  | \text{ \gemph{chan(n:nat,b:bool)} } | \dots\)
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operational semantics (2)}
  Small-step operational semantics with inductively defined relations:
  \begin{itemize}
    \item $\text{pure\_step} \subseteq \text{expr} \times \text{expr}$
    \item $\text{head\_step} \subseteq (\text{expr} \times \text{buffers})
          \times (\text{expr} \times \text{buffers} \times \overbrace{\text{list expr}}^\text{spawned threads})$

    \item $\text{ctx} \subseteq \text{expr} \to \text{expr}$
    \item $\text{ctx\_step} \subseteq (\text{expr} \times \text{buffers})
          \times (\text{expr} \times \text{buffers} \times \text{list expr})$
          \item $\text{step} \subseteq (\text{list expr} \times \text{buffers}) \times (\text{list expr} \times \text{buffers})$
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Operational semantics (3)}
  \textbf{In Coq:}
  \begin{lstlisting}
Inductive head_step :
    expr -> heap -> expr -> heap -> list expr -> Prop :=
| Pure_step : forall e e' h,
  pure_step e e' -> head_step e h e' h []
| Send_step : forall h c y buf,
   h !! (other c) = Some buf ->
   head_step (Send (Val (ChanV c)) (Val y)) h
             (Val (ChanV c)) (<[ other c := buf ++ [y] ]> h) []
| ...
  \end{lstlisting}
\end{frame}

% Inductive type :=
%     | UnitT : type
%     | NatT : type
%     | PairT : type -> type -> type
%     | FunT : type -> type -> type
%     | ChanT : chan_type -> type

% with chan_type :=
%     | SendT : type -> chan_type -> chan_type
%     | RecvT : type -> chan_type -> chan_type
%     | EndT : chan_type.

\begin{frame}[fragile]
  \frametitle{Type system rules (1)}
  \begin{itemize}
    \item \textbf{Grammar of types:}\begin{equation*}
      \begin{split}
      \text{type}  ::= & \text{ unit} \\
        | & \text{ type $\times$ type} \\
        | & \text{ type $\to$ type} \\
        | & \text{ chan\_type } \\
        | & \dots
      \end{split}
      \end{equation*}
  \item \textbf{Channel protocols:}\begin{equation*}
      \begin{split}
      \text{chan\_type}  ::= & \text{ !type, chan\_type} \\
        | & \text{ ?type, chan\_type} \\
        | & \text{ End} \\
        | & \dots
      \end{split}
      \end{equation*}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Type system rules (2)}

  The type system is also inductively defined:
  \begin{itemize}
    \item Judgement: $\Gamma \vdash e : t$
    \item $(\cdot \vdash \cdot : \cdot) \subseteq \text{env} \times \text{expr} \times \text{type}$
    \item $\text{env} = \text{var} \to_\text{fin} \text{type}$
  \end{itemize}

  \begin{mathpar}
    \inferrule*[right=Var]
    {.}
    {\{x\mapsto t\} \vdash x : t}

    \inferrule*[right=Nat]
    {n \in \mathbb{N}}
    {\emptyset \vdash n : Nat}

    \inferrule*[right=App]
    {\Gamma_1 \vdash e_1 : t_1 \to t_2 \and \Gamma_2 \vdash e_2 : t_1 \and \Gamma_1 \cap \Gamma_2 = \emptyset}
    {(\Gamma_1 \cup \Gamma_2) \vdash e_1\ e_2 : t_2}

    % \inferrule*[right=Lam]
    % {(\Gamma \cup \{x \mapsto t_1\}) \vdash e : t_2 \and x \notin \Gamma}
    % {\Gamma \vdash \text{fun } x \implies e : t_1 \to t_2}

    \inferrule*[right=Send]
    {\Gamma_1 \vdash e_1 :\ !t, R \and \Gamma_2 \vdash e_2 : t \and \Gamma_1 \cap \Gamma_2 = \emptyset}
    {(\Gamma_1 \cup \Gamma_2) \vdash \text{send}(e_1, e_2) : R}
  \end{mathpar}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Properties that we want to prove}
  \begin{itemize}
    \item Suppose we have a top level well-typed program $\emptyset \vdash e : \text{unit}$
    \item We initialize the state with $S_0 = ([e],[])\subseteq \text{threads}\times\text{buffers}$
    \item We then run the operational semantics $\text{step} \subseteq (\text{threads} \times \text{buffers})
              \times (\text{threads} \times \text{buffers})$ \\
          to get a new state $S' = ([e_1, e_2, \dots], \{(0,true) \mapsto buf_{00}, (0,false) \mapsto buf_{01}, \dots\})$
  \end{itemize}

  \bigskip
  \textbf{We want to establish these properties:}
  \begin{itemize}
    \item Each expression $e_i$ in $S'$ either
    \begin{enumerate}
      \item Is a unit value, or
      \item Is waiting on recv(chan(n,b), v), or
      \item Can take a step
    \end{enumerate}
    \item If $S'$ can not take \emph{any} further step, then
    \begin{enumerate}
      \item All the $e_i$ are unit values, and
      \item All the buffers are empty
    \end{enumerate}
  \end{itemize}
  \gemph{These properties rule out type errors, use-after-close, deadlocks, and leaks.}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Method: progress \& preservation}
  \textbf{Idea of progress \& preservation:} \\
  Choose a set of well-behaved states $W \subseteq (\text{threads}\times\text{buffers})$.
  \begin{itemize}
    \item Show that $S_0 \in W$
    \item \textbf{Preservation:} Show that if $S \in W$ and $(S,S') \in \text{step}$, then $S' \in W$.
    \item \textbf{Progress:} Show that the properties that we want hold for states in $W$.
  \end{itemize}

  \bigskip
  \textbf{What do we want of W?}

  Choose $W$ such that $([e_1, e_2, \dots], \{(0,true) \mapsto buf_{00}, (0,false) \mapsto buf_{01}, \dots\}) \in W$ if
  \begin{itemize}
    \item All the expressions $e_i$ are well-typed.
    \item All the values in the buffers are well-typed.
    \item For each channel $n\in \mathbb{N}$, there is exactly one $\text{chan}(n,true)$ and one $\text{chan}(n,false)$.
    \begin{itemize}
      \item These channel references may occur inside one of the $e_i$ or inside one of the buffers.
      \item The types of the $chan(n,b)$ must be consistent with the values inside the buffers.
    \end{itemize}
    \item The connectivity between channels and threads is \emph{acyclic}.
    \begin{itemize}
      \item Otherwise we can have a deadlock due to cyclic waiting.
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Two type systems: user facing type system \& run-time type system}
  \begin{itemize}
    \item The initial expression $e$ does not have any $chan(n,b)$ in it
    \item Once the operational semantics steps, these channel references apprear inside the $e_i$
    \item And inside the buffers (when sending channels over channels)
  \end{itemize}

  \bigskip
  \remph{Problem: The type system does not know what to do with $chan(n,b)$}\\
  \gemph{Solution: Define an extended type system that can handle $chan(n,b)$}

  \bigskip
  \textbf{Extended type system judgement: } $\Gamma, \Sigma \vdash e : t$
  \begin{itemize}
    \item $\Gamma$ tells us the types of variables
    \item $\Sigma$ tells us the types of $chan(n,b)$'s
  \end{itemize}
  Both $\Gamma$, $\Sigma$ split up \emph{disjointly} over subexpressions.
\end{frame}

\begin{frame}[fragile]
  \frametitle{Run-time type system: separation logic}
  Inference rule of extended type system:
  \begin{mathpar}
    \inferrule*[]
    {\Gamma_1, \Sigma_1 \vdash e_1 : t_1 \to t_2 \and \Gamma_2, \Sigma_2 \vdash e_2 : t_1 \and \Gamma_1 \cap \Gamma_2 = \emptyset \and \Sigma_1 \cap \Sigma_2 = \emptyset}
    {(\Gamma_1 \cup \Gamma_2), (\Sigma_1 \cup \Sigma_2) \vdash e_1\ e_2 : t_2}
  \end{mathpar}

  We use \textbf{separation logic} to hide the $\Sigma$'s:
  \begin{mathpar}
    \inferrule*[right=*]
    {\Gamma_1 \vdash e_1 : t_1 \to t_2 \and * \and \Gamma_2 \vdash e_2 : t_1 \and \Gamma_1 \cap \Gamma_2 = \emptyset}
    {(\Gamma_1 \cup \Gamma_2) \vdash e_1\ e_2 : t_2}
  \end{mathpar}

  Instead of an \textbf{implication} with \textbf{conjunction} between the premises,\\
  we have a \textbf{magic wand} with \textbf{separating conjection} between the premises.

  \bigskip
  We need to transfer ownership of channels as the expressions take steps, and as values get put in and taken out of buffers. \\
  \gemph{Separation logic allows us to reason about linear channel ownership at a high level.}\\
  \textbf{Low-level view:} $\Sigma$ is split up and re-distributed over parts of the state as the state evolves.\\
  \textbf{High-level view:} separation logic invariant hold, ownership gets transfered.
\end{frame}

\begin{frame}[fragile]
  \frametitle{The connectivity graph}
  \begin{itemize}
    \item A graph containing threads (boxes) and channels (circles)
    \item An arrow $T \to C$ means that thread $T$ has a reference to channel $C$
      \begin{itemize}
        \item This means that $T$ contains a channel reference to $C$
      \end{itemize}
    \item An arrow $C1 \to C2$ means that channel $C1$ has a reference to channel $C2$
      \begin{itemize}
        \item This means that somewhere in the buffer of $C1$ there is a reference to $C2$
      \end{itemize}
  \end{itemize}
  \medskip

  \trimbox{-2cm 0cm 0cm 0cm}{
  \fbox{\begin{tikzpicture}[node distance=1.5cm]
    \node (T1) [thread] {T1};
    \node (C1) [channel, below of = T1] {C1};
    \node (T2) [thread, below of = C1] {T2};
    \draw [arrow] (T1) -- (C1);
    \draw [arrow] (T2) -- (C1);

    \node (C2) [channel, right of = C1] {C2};
    \draw [arrow] (C1) -- (C2);

    \node (T3) [thread, right of = C2] {T3};
    \draw [arrow] (T3) -- (C2);

    \node (C3) [channel, right of = T3] {C3};
    \draw [arrow] (T3) -- (C3);

    \node (T4) [thread, above of = C3] {T4};
    \draw [arrow] (T4) -- (C3);
  \end{tikzpicture}}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Deadlocks}

  \remph{Cyclic connectivity graphs can result in deadlock:} \bigskip

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \node (C2) [channel, right of = T2] {C2};
      \node (T3) [thread, right of = C2] {T3};
      \node (C3) [channel, above of = T3] {C3};
      \node (T4) [thread, above of = C3] {T4};
      \node (C4) [channel, left of = T4] {C4};

      \draw [arrow] (T1) -- (C1);
      \draw [arrow] (T1) -- (C4);

      \draw [arrow] (T2) -- (C1);
      \draw [arrow] (T2) -- (C2);

      \draw [arrow] (T3) -- (C2);
      \draw [arrow] (T3) -- (C3);

      \draw [arrow] (T4) -- (C3);
      \draw [arrow] (T4) -- (C4);
    \end{tikzpicture}}}

    \bigskip
    T1 waits to receive from C1, then sends to C4\\
    T2 waits to receive from C2, then sends to C1\\
    T3 waits to receive from C3, then sends to C2\\
    T4 waits to receive from C4, then sends to C3\\
    \bigskip
    \gemph{Invariant: the connectivity graph is acyclic}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The evolution of the connectivity graph: initial}

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \draw [arrow] (T1) --node[right]{!Nat,End} (C1);
      \draw [arrow] (T2) --node[right]{?Nat,End} (C1);

      % \node (C2) [channel, right of = C1] {C2};
      % \draw [arrow] (C1) -- (C2);

      % \node (T3) [thread, right of = C2] {T3};
      % \draw [arrow] (T3) -- (C2);

      % \node (C3) [channel, right of = T3] {C3};
      % \draw [arrow] (T3) -- (C3);

      % \node (T4) [thread, above of = C3] {T4};
      % \draw [arrow] (T4) -- (C3);
    \end{tikzpicture}}}
    \begin{verbatim}
      own_edge T1 c1 (true,t)
      own_edge T2 c1 (false,dual(t))

      c1 : !(?Nat, End), End.
      T1 := let c1' = send(c1',3); close(c1')
      T2 :=
        let c4 = fork(fun c4' =>
          let (c4',c1) = recv(c4')
          let (c1,n) = recv(c1)
          close(c1))
        let c4 = send(c4, c1) in close(c4)
    \end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The evolution of the connectivity graph: initial}

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \draw [arrow] (T1) --node[right]{!Nat,End} (C1);
      \draw [arrow] (T2) --node[right]{?Nat,End} (C1);

      \node (C4) [channel, right of = T2] {C4};
      \draw [arrow] (T2) --node[left,rotate=90]{!(?Nat,End),End} (C4);

      \node (T5) [thread, right of = C4] {T5};
      \draw [arrow] (T5) --node[left,rotate=90]{?(?Nat,End),End} (C4);
    \end{tikzpicture}}}
    \begin{verbatim}
      own_edge T1 c1 (true,(!Nat,End))
      own_edge T2 c1 (false,(?Nat,End)
      own_edge T2 c4 (true,(!(!Nat,End),End))
      own_edge T5 c4 (false,(?(!Nat,End),End))

      c1 : !(?Nat, End), End.
      T1 := let c1' = send(c1',3); close(c1')
      T2 := let c4 = send(c4, c1) in close(c4)
      T5 = let (c4',c1) = recv(c4')
            let (c1,n) = recv(c1)
            close(c1)
    \end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The evolution of the connectivity graph: initial}

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \draw [arrow] (T1) --node[right]{!Nat,End} (C1);
      \draw [arrow] (C4) --node[right]{?Nat,End} (C1);

      \node (C4) [channel, right of = T2] {C4};
      \draw [arrow] (T2) --node[left,rotate=90]{!(?Nat,End),End} (C4);

      \node (T5) [thread, right of = C4] {T5};
      \draw [arrow] (T5) --node[left,rotate=90]{?(?Nat,End),End} (C4);
    \end{tikzpicture}}}
    \begin{verbatim}
      own (c1,true) T1 (!Nat,End)
      own (c1,false) c4 (?Nat,End)
      own (c4,true) T2 (!(!Nat,End),End)
      own (c4,false) T5 (?(!Nat,End),End)

      c1 : !(?Nat, End), End.
      T1 := let c1' = send(c1',3); close(c1')
      T2 := close(c4)
      T5 = let (c4',c1) = recv(c4')
            let (c1,n) = recv(c1)
            close(c1)

      Inductive owner := Thread nat | Chan chan
      own : endpoint -> owner -> chan_type -> iProp
      \Sigma : heapT (= gmap endpoint (owner * chan_type))
      own ep owner t :=
        ownM (\frag {[ ep := (owner,t) ]})

      A := owner
      graph A := gset (A * A)

      own_auth : heapT -> iProp
      own_auth \Sigma :=
        ownM (\auth \Sigma) \star
        \exists G, related G \Sigma \and acyclic_forest G

      "G := sym_closure ({ (ep.1, owner) : \Sigma !! ep = Some (owner,t) })"

      related G \Sigma :=
        symmetric G \and
        \all ep owner t,
          \Sigma !! ep = Some (owner,t)
             ->
          (Chan ep.1, owner) \in G

    \end{verbatim}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The evolution of the connectivity graph: fork}

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \draw [arrow] (T1) -- (C1);
      \draw [arrow] (T2) -- (C1);

      \node (C2) [channel, right of = C1] {C2};
      \draw [arrow] (C1) -- (C2);

      \node (T3) [thread, right of = C2] {T3};
      \draw [arrow] (T3) -- (C2);

      \node (C3) [channel, right of = T3] {C3};
      \draw [arrow] (T3) -- (C3);

      \node (T4) [thread, above of = C3] {T4};
      \draw [arrow] (T4) -- (C3);

      \node (C4) [channel, right of = T2] {C4};
      \draw [arrow, color=red] (T2) -- (C4);

      \node (T5) [thread, right of = C4] {T5};
      \draw [arrow, color=red] (T5) -- (C4);
    \end{tikzpicture}}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The evolution of the connectivity graph: send C1 over C4}

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \draw [arrow] (T1) -- (C1);
      \draw [arrow, color=red] (C4) -- (C1);

      \node (C2) [channel, right of = C1] {C2};
      \draw [arrow] (C1) -- (C2);

      \node (T3) [thread, right of = C2] {T3};
      \draw [arrow] (T3) -- (C2);

      \node (C3) [channel, right of = T3] {C3};
      \draw [arrow] (T3) -- (C3);

      \node (T4) [thread, above of = C3] {T4};
      \draw [arrow] (T4) -- (C3);

      \node (C4) [channel, right of = T2] {C4};
      \draw [arrow] (T2) -- (C4);

      \node (T5) [thread, right of = C4] {T5};
      \draw [arrow] (T5) -- (C4);
    \end{tikzpicture}}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{The evolution of the connectivity graph: receive C1 over C4}

  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (C1) [channel, below of = T1] {C1};
      \node (T2) [thread, below of = C1] {T2};
      \draw [arrow] (T1) -- (C1);
      \draw [arrow, color=red] (T5) -- (C1);

      \node (C2) [channel, right of = C1] {C2};
      \draw [arrow] (C1) -- (C2);

      \node (T3) [thread, right of = C2] {T3};
      \draw [arrow] (T3) -- (C2);

      \node (C3) [channel, right of = T3] {C3};
      \draw [arrow] (T3) -- (C3);

      \node (T4) [thread, above of = C3] {T4};
      \draw [arrow] (T4) -- (C3);

      \node (C4) [channel, right of = T2] {C4};
      \draw [arrow] (T2) -- (C4);

      \node (T5) [thread, right of = C4] {T5};
      \draw [arrow] (T5) -- (C4);
    \end{tikzpicture}}}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Concurrent objects}

  \gemph{We can generalize from channels to other concurrent objects, such as locks.}
  \bigskip


  \trimbox{-2cm 0cm 0cm 0cm}{
    \fbox{\begin{tikzpicture}[node distance=1.5cm]
      \node (T1) [thread] {T1};
      \node (T2) [thread, below of = T1] {T2};

      \node (L1) [lock, right of = T1] {L1};

      \node (T3) [thread, right of = L1] {T3};
      \draw [arrow] (T3) -- (L1);

      \node (C3) [channel, right of = T3] {C3};
      \draw [arrow] (T3) -- (C3);

      \node (T4) [thread, above of = C3] {T4};
      \draw [arrow] (T4) -- (C3);

      \node (C4) [channel, right of = T2] {C4};
      \draw [arrow] (T2) -- (C4);

      \node (T5) [thread, right of = C4] {T5};
      \draw [arrow] (T5) -- (C4);

      \draw [arrow] (T2) -- (L1);
      \draw [arrow] (T1) -- (L1);
    \end{tikzpicture}}}

    \bigskip
    \textbf{Required property:} \gemph{no local deadlock}
    \begin{itemize}
      \item Channels: local deadlock means both sides do a receive
      \begin{itemize}
        \item Ruled out by type system
      \end{itemize}
      \item Locks: local deadlock means all threads are waiting on the lock
      \begin{itemize}
        \item Can't happen: one of the threads must have succesfully acquired the lock
      \end{itemize}
    \end{itemize}
    \textbf{Connectivity graph is a tree:} \gemph{no local deadlock $\implies$ no deadlock}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Coq proof}

  The Coq proof is work in progress...
  \begin{itemize}
    \item \gemph{Language \& type system}
    \item \gemph{Separation logic}
    \item \gemph{Run-time type system}
    \item \gemph{Type-safety invariant}
    \item \gemph{Library for tree reasoning}
    \item \gemph{Preservation o}\remph{f type safety invariant}
    \item \remph{Preservation of tree invariant}
    \item \remph{Invariant $\implies$ desired properties}
    \item \remph{Extensions}
  \end{itemize}

\end{frame}

\begin{frame}[fragile]
  \begin{center}
    \Huge Questions?
  \end{center}
\end{frame}


% \begin{frame}[fragile]
%   \frametitle{Operational semantics}
%   \begin{itemize}
%     \item Small-step operational semantics
%     \item State: threads $\times$ buffers
%     \item Pairs of buffers indexed by addresses (e.g. natural numbers); two buffers per channel
%     \item Representation of a channel is address $\times$ bool, e.g. \lstinline|send(#(324, true))|
%     \item \lstinline|send(#(324,true), "hello")| $\mapsto$ \lstinline|#(324,true)|
%     \item Send adds message to the other party's buffer
%     \item Receive takes a message out of its own buffer
%     \item Fork allocates a new pair of buffers, returns \lstinline|#(n,true)| to one
%           side and passes \lstinline|#(n,false)| to the other
%     \item Close deallocates its own buffer
%   \end{itemize}
%   In Coq:
%   \begin{lstlisting}
%     endpoint = nat x bool
%     heap = endpoint -> option (list val)
%     local_step : expr x heap -> expr x heap -> Prop
%     step : list expr x heap -> list expr x heap -> Prop
%   \end{lstlisting}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Formal properties}
%   The step relation is undefined for invalid states.

%   For example, if an expression is \lstinline|3 + "hi"|, then that expression cannot step further.

%   Safety property:

%   Either the state can take a step, or it's in a valid end-state.


%   Formal properties:
%   \begin{itemize}
%     \item Safety
%     \item Deadlock freedom
%     \item Leak freedom
%   \end{itemize}

%   \begin{theorem}
%     Typed expr -> previous 3 properties
%   \end{theorem}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Progress \& preservation}

% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Formal properties}
%   High level approach:
%   \begin{itemize}
%     \item Progress \& preservation (explain this) $\implies$ safety
%     \item Progress \& preservation for linear types
%     \item Connectivity tree
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Typing channel references}
%   \begin{itemize}
%     \item When the operational semantics takes steps, channel references (e.g. \lstinline|#(324, true)|) enter into the program.
%     \item How do we type them?
%     \item We need a typing rule for channel references.
%     \item We need an environment $\Sigma$ for channel references, similar to $\Gamma$ for variables
%     \item If $((342,true), T) \in \Sigma$ then \lstinline|#(324,true) : T|
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Typing channel references with separation logic}
%   How to explain this...?
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{The connectivity graph}
%   \begin{itemize}
%     \item A graph containing threads (boxes) and channels (circles)
%     \item An arrow $T \to C$ means that thread $T$ has a reference to channel $C$
%       \begin{itemize}
%         \item This means that some data structure that $T$ holds contains a channel reference to $C$
%       \end{itemize}
%     \item An arrow $C1 \to C2$ means that channel $C1$ has a reference to channel $C2$
%       \begin{itemize}
%         \item This means that somewhere in the buffer of $C1$ there is a reference to $C2$
%       \end{itemize}
%   \end{itemize}
%   \medskip

%   \trimbox{-2cm 0cm 0cm 0cm}{
%   \fbox{\begin{tikzpicture}[node distance=1.5cm]
%     \node (T1) [thread] {T1};
%     \node (C1) [channel, below of = T1] {C1};
%     \node (T2) [thread, below of = C1] {T2};
%     \draw [arrow] (T1) -- (C1);
%     \draw [arrow] (T2) -- (C1);

%     \node (C2) [channel, right of = C1] {C2};
%     \draw [arrow] (C1) -- (C2);

%     \node (T3) [thread, right of = C2] {T3};
%     \draw [arrow] (T3) -- (C2);

%     \node (C3) [channel, right of = T3] {C3};
%     \draw [arrow] (T3) -- (C3);

%     \node (T4) [thread, above of = C3] {T4};
%     \draw [arrow] (T4) -- (C3);
%   \end{tikzpicture}}}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Deadlock freedom}
%   \begin{itemize}
%     \item Invariant: the connectivity graph is a tree.
%     \item Even when channel references are put in buffers.
%     \item Ensured by linearity.
%   \end{itemize}
% \end{frame}

% \begin{frame}[fragile]
%   \frametitle{Deadlock freedom}
%   \begin{theorem}
%     There is a thread that's not blocked.
%   \end{theorem}
%   \begin{proof}
%     We find a thread that's not blocked using this algorithm:
%     \begin{itemize}
%       \item Start at any thread in the connectivity graph.
%       \item If the thread is not blocked, we're done.
%       \item If the thread is blocked, step to the channel that it's blocked on.
%       \item If we're at a channel
%     \end{itemize}
%   \end{proof}
% \end{frame}

\end{document}