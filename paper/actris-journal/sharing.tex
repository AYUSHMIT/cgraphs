\section{Manifest sharing via locks}
\label{sec:integration}

Since \pname and the connective $\interp \chan \prot$ for ownership of protocols
are first-class objects of the \lname logic, they can be used like any other
logical connective.
This means that protocols can be combined with any other
mechanism that \lname inherits from Iris.
In particular, they can be combined with Iris's generic invariant and ghost
state mechanism, and can be used in combination with Iris's
abstractions for reasoning about other concurrency connectives like locks,
barriers, lock-free data structures, \etc

In this section we demonstrate how \pname can be combined with lock-based
concurrency.
This combination allows us to prove functional correctness of programs that
make use of the notion of \emph{manifest sharing} \cite{balzer-PACMPL2017, balzer-ESOP2019},
where channel endpoints are shared between multiple parties.
Instead of having to extend \lname, we make use of locks and ghost state that
\lname readily inherits from Iris.
We present the basic idea with a simple introductory example of sharing a channel
endpoint between two parties (\Cref{sec:locks}).
We then consider a more challenging example of a distributed load-balancing
mapper (\Cref{sec:mapper}).

\subsection{Locks and ghost state}
\label{sec:locks}

\newcommand{\locksfig}{
\begin{figure}
\begin{align*}
\hoare
  {\ipropC}
  {&\newlock}
  {\Ret\lockvar. \islock \lockvar \ipropC}
  \tagH{Ht-new-lock} \\
\hoare
  {\islock \lockvar \ipropC}
  {&\acquire \lockvar}
  \ipropC
  \tagH{Ht-acquire} \\
\hoare
  {\islock \lockvar \ipropC * \ipropC}
  {&\release \lockvar}
  \TRUE
  \tagH{Ht-release} \\
\islock \lockvar \ipropC \wand\ &
  \islock \lockvar \ipropC * \islock \lockvar \ipropC
  \tagH{Lock-dup}
\end{align*}
\caption{The rules \lname inherits from Iris for locks.}
\label{fig:locks}
\end{figure}}

\newcommand{\locksimplefig}{
\begin{figure}
\begin{align*}
\simpleexamplename \eqdef{}&
  \LetNoIn \chan = \start {(\Lam \chan.
    \begin{array}[t]{@{}l@{}}
      \Let \lockvar = \newlock in \\
      \Fork { \acquirelock \lockvar;\ \send \chan {21};\ \releaselock \lockvar };\\
      \acquirelock \lockvar;\ \send \chan {21};\ \releaselock \lockvar)\ \In
    \end{array}
  } \\
  & \recv \chan + \recv \chan
\end{align*}
\caption{A sample program that combines locks and channels to
achieve manifest sharing.}
\label{fig:lock_simple}
\end{figure}}

\newcommand{\authfig}{
\begin{figure}
\begin{align*}
\TRUE \vs{}& \Exists\gname. \serverpredT \gname 0
  \tagH{Auth-init} \\
\serverpredT \gname n \vs{}&
  \clientpredT \gname * \serverpredT \gname {(1 + n)}
  \tagH{Auth-alloc} \\
\serverpredT \gname {(1 + n)} * \clientpredT \gname \vs{}&
  \serverpredT \gname n
  \tagH{Auth-dealloc} \\
\serverpredT \gname n * \clientpredT \gname \wand{}&
  n > 0
  \tagH{Auth-contrib-pos}
\end{align*}
\caption{The authoritative contribution ghost theory.}
\label{fig:auth}
\end{figure}}

Using the language from \Cref{sec:language} it is possible to implement
locks using a spin lock, ticket lock, or a more sophisticated implementation.
For the purpose of this paper, we abstract over the concrete implementation
and assume that we have operations $\newlockname$, $\acquirelockname$ and $\releaselockname$
that satisfy the common separation logic specifications for locks as shown
in \Cref{fig:locks}.

\locksfig
\locksimplefig

The $\newlock$ operation creates a new lock, which can be thought of as a mutex.
The operation $\acquirelock \lockvar$ will atomically take the lock or block in
the case the lock is already taken,
and $\releaselock \lockvar$ releases the lock so that it may be acquired by other
threads.
The specifications in \Cref{fig:locks} make use of the representation
predicate $\islock \lockvar \ipropC$, which expresses that a lock $\lockvar$ guards
the resources described by the proposition $\ipropC$.
When creating a new lock one has to give up ownership of $\ipropC$, and in turn,
obtains the representation predicate $\islock \lockvar \ipropC$ (\ruleref{Ht-new-lock}).
The representation predicate can then be freely duplicated so it
can be shared between multiple threads (\ruleref{Lock-dup}).
When entering a critical section using $\acquire \lockvar$, a thread gets exclusive
ownership of $\ipropC$ (\ruleref{Ht-acquire}), which has to be given up
when releasing the lock using $\release \lockvar$ (\ruleref{Ht-release}).
The resources $\ipropC$ that are protected by the lock are therefore invariant
in-between any of the critical sections.

To show how locks can be used, consider the program in
\Cref{fig:lock_simple}, which uses a lock to share a channel endpoint
between two threads, that each send $21$ to the main thread.
The following dependent protocol, where $n$ denotes the number of messages that
should be exchanged, captures the expected interaction from the point of view of the
main thread:
\[
\lockprotname \eqdef \MU (\recvar : \nat \rightarrow \iProto). \Lam n.
 \If (n=0) then \protend \Else \recvprotT{}{21}{\recvar\ (n-1)}
\]

\noindent
Since $\interp \chan {\dual {\lockprotname\ n}}$ is an exclusive resource, we
need a lock to share it between the threads that send $21$.
For this we will use the following lock invariant:
\[
\islock \lockvar {(\Exists n.
   \serverpredT \gname n * \interp \chan {\dual {\lockprotname\ n}})}
\]

\noindent
The natural number $n$ is existentially quantified since it changes
over time depending on the values that are sent.
To tie the number $n$ to the number of contributions made by the  threads that
share the channel endpoint, we make use of the connectives
$\serverpredT \gname n$ and $\clientpredT \gname$, which are defined using
Iris's ``ghost theory'' mechanism for ``user-defined'' ghost
state~\cite{jung-POPL2015,jung-JFP2018}.

\authfig

The $\serverpredT \gname n$ fragment can be thought of as an authority that
keeps track of the number of ongoing contributions $n$, while each
$\clientpredT \gname$ is a token that witnesses that a contribution is still in
progress.
These concepts are made precise by the rules in \Cref{fig:auth}.
The rule \ruleref{Auth-init} expresses that an authority $\serverpredT \gname 0$
can always be created, which is given some fresh ghost identifier $\gname$.
Using the rules \ruleref{Auth-alloc} and \ruleref{Auth-dealloc}, one can
allocate and deallocate tokens $\clientpredT \gname$ as long as the count $n$
of ongoing contributions in $\serverpredT \gname n$ is updated accordingly.
The rule \ruleref{Auth-contrib-pos} expresses that ownership of a token
$\clientpredT \gname$ implies that the count $n$ of $\serverpredT \gname n$
must be positive.

Most of the rules in \Cref{fig:auth} involve the logical connective $\vs$
of a so-called \textit{view shift}.
The view shift connective, which \lname inherits from Iris, can be though of
as a ``ghost update'', which is made precise by the structural rules
\ruleref{Vs-csq} and \ruleref{Vs-frame} rules, that establish
the connection between $\vs$ and the Hoare triples of the logic:
\begin{mathpar}
\inferH{Vs-csq}
  {\iprop \vs \iprop' \and
   \hoare {\iprop'} \expr {\Ret\val. \ipropB'} \and
   \All\val. \ipropB' \vs \ipropB}
  {\hoare \iprop \expr {\Ret\val. \ipropB}}
\and
\inferH{Vs-frame}
  {\iprop \vs \ipropB}
  {\iprop * \ipropC \vs \ipropB * \ipropC}
\end{mathpar}

\noindent
With the ghost state in place, we can now state suitable specifications
for the program.
The specification of the top-level program is shown on the right, while the
left Hoare triple shows the auxiliary specification of both threads that send
the integer $21$:
\[
\begin{array}{l @{\qquad} l}
\hoareV
  {\clientpredT \gname *
   \islock \lockvar {(\Exists n.
   \serverpredT \gname n * \interp \chan {\dual {\lockprotname\ n}})}}
  {\acquirelock \lockvar;\ \send \chan {21};\ \releaselock\lockvar}
  \TRUE
&
  \hoareV \TRUE \simpleexamplename {\Ret\val. \val = 42}
\end{array}
\]
To establish the initial lock invariant, we use the rules \ruleref{Auth-init}
and \ruleref{Auth-alloc} to create the authority $\serverpredT \gname 2$ and
two $\clientpredT \gname$ tokens.
The $\clientpredT \gname$ tokens play a crucial role in the proofs of the
sending threads to establish that the existentially quantified variable $n$ is
positive (using \ruleref{Auth-contrib-pos}).
Knowing $n > 0$, these threads can establish that the protocol
$\dual {\lockprotname\ n}$ has not terminated yet (\ie is not $\protend$).
This is needed to use the rule \ruleref{Ht-send} to prove the correctness of
sending $21$, and thereby advancing the protocol from
$\dual {\lockprotname\ n}$ to $\dual {\lockprotname\ (n-1)}$.
Subsequently, the sending threads can deallocate the token $\clientpredT \gname$
(using \ruleref{Auth-dealloc}) to decrement the $n$ of $\serverpredT \gname n$
accordingly to restore the lock invariant.

\subsection{A distributed load-balancing mapper}
\label{sec:mapper}

\newcommand{\parmapperworkerfig}{
\begin{figure}
\begin{equation*}
\begin{array}{@{} l @{}}
\parmapperworkername\ \vmapvar\ \lockvar\ \chan \eqdef \\
\quad \begin{array}[t]{@{} l @{}}
  \acquirelock{\lockvar};\
  \select \chan \leftname;\\
  \mbranch \chan
    \rightname {\release \lockvar}
    \leftname {
      \begin{array}[t]{@{} l !{\quad\quad}  l @{}}
      \Let \var = \recv\chan in
      \releaselock \lockvar; & \Comment{acquire work} \\
      \Let \varB = \vmapvar\ \var in & \Comment{map it} \\
      \acquirelock \lockvar;\\
      \quad \select \chan \rightname;\
      \send \chan \varB; & \Comment{send it back} \\
      \releaselock \lockvar; \\
      \parmapperworkername\ \vmapvar\ \lockvar\ \chan
      \end{array}}
  \end{array}
\end{array}
\end{equation*}
\caption{A worker of the distributed mapper service.}
\label{fig:mapperworker}
\end{figure}}

\newcommand{\authMfig}{
\begin{figure}
\begin{align*}
\TRUE \vs{}&
  \Exists\gname. \serverpred \gname 0 \emptyset
  \tagH{AuthM-init} \\
\serverpred \gname n X \vs{}&
  \serverpred{\gname}{(1 + n)}{X} * \clientpred \gname \emptyset
  \tagH{AuthM-alloc} \\
\serverpred \gname n X * \clientpred \gname \emptyset \vs{}&
  \serverpred \gname {(n-1)} X
  \tagH{AuthM-dealloc} \\
\serverpred \gname n X * \clientpred{\gname}{Y} \vs{}&
  \serverpred \gname n {(X \uplus Z)} * \clientpred \gname {(Y \uplus Z)}
  \tagH{AuthM-add} \\
Z \subseteq Y * \serverpred \gname n X * \clientpred \gname Y \vs{}&
  \serverpred \gname n {(X \setminus Z)} * \clientpred \gname {(Y \setminus Z)}
  \tagH{AuthM-remove} \\
\serverpred \gname n X * \clientpred \gname Y \wand{}&
  n > 0 * Y \subseteq X
  \tagH{AuthM-contrib-agree} \\
\serverpred \gname 1 X * \clientpred \gname Y \wand{}&
  Y = X
  \tagH{AuthM-contrib-agree1}
\end{align*}
\caption{The authoritative contribution ghost theory extended with multisets.}
\label{fig:authM}
\end{figure}}

This section demonstrates a more interesting use of manifest sharing.
We show how \lname can be used to verify functional correctness
of a distributed load-balancing mapper that maps a function $\vmapvar$ over a list.
Our distributed mapper consists of one client that distributes the work, and a
number of workers that perform the function $\vmapvar$ on individual elements of
the list.
To enable communication between the client and the workers, we make use of
a single channel.
One endpoint is used by the client to distribute the work between the workers,
while the other endpoint is shared between all workers to request and
return work from the client.
The implementation of the workers, which can be found in
\Cref{fig:mapperworker}, consists of a loop over three phases:
\begin{enumerate}
\item The worker notifies the client that it wants to perform work (using
  $\select \chan \leftname$), after which it is then notified (using
  $\langkw{branch}$) whether there is more work or all elements have been mapped.
  If there is more work, the worker receives an element $\var$ that needs to
  be mapped.
  Otherwise, the worker will terminate.
\item The worker maps the function $\vmapvar$ on $\var$.
\item The worker notifies the client that it wants to send back a result
  (using $\select \chan \rightname$), and subsequently sends back the
  result $\varB$ of mapping $\vmapvar$ on $\var$.
\end{enumerate}
The first and last phases are in a critical section guarded by a lock $\lockvar$
since they involve interaction over a shared channel endpoint.
As the sharing behaviour is encapsulated by the worker, we omit the code of the client
for brevity's sake.\footnote{The entire code is present in
the accompanied Coq development~\cite{actris_coq}.}
\parmapperworkerfig
\authMfig

A protocol that describes the interaction from the client's point of view is
as follows:
\[
\begin{array}{l}
\parmapperprotname\
  (\interpvar_\tvar : \tvar \to \Val \to \Prop)\
  (\interpvar_\tvarB : \tvarB \to \Val \to \Prop)\
  (\mapvar : \tvar \to \List\ \tvarB) \eqdef\\
\quad \MU (\recvar : \nat \to \MultiSet\ \tvar \to \iProto). \Lam n\ X. \\
\quad\quad \begin{array}{@{} l @{}}
  \If n=0 then \protend \Else\\
  \begin{array}[t]{@{} l @{}}
    \mbranchprotprop
      {\selectprot
        {(\sendprot{(\var : \tvar)\ (\val : \Val)}
          \val
          {\interpvar_\tvar\ \var\ \val}
          {\recvar\ n\ (X \uplus \{\var\})})}
        {\recvar\ (n-1)\ X}}
      {(n = 1) \Ra (X = \emptyset)}
      \TRUE
      {\recvprot {(\var : \tvar)\ (\loc : \Loc)}
        \loc
        {\var \in X * \listrefI{\interpvar_\tvarB} \loc {(\mapvar\ \var)}}
        {\recvar\ n\ (X \setminus \{ x \})}}
  \end{array}
\end{array}
\end{array}
\]
Similarly to $\mapperprotname$ from \Cref{sec:subprotocol_swapping}, the protocol is
parameterised by representation predicates $\interpvar_\tvar$
and $\interpvar_\tvarB$, and a function $\mapvar : \tvar \to \List\ \tvarB$ in
Iris/\lname logic,
related through the $\mapspecname$ specification.
Similar to the protocol $\lockprotname$ from \Cref{sec:locks}, the protocol
$\parmapperprotname$ is indexed by the number of remaining workers $n$.
On top of that, it carries a multiset $X$ describing the values currently
being processed by all the workers.
The multiset $X$ is used to make sure that the returned results are in
fact the result of mapping the function $\mapvar$.
The condition $(n = 1) \Ra (X = \emptyset)$ on the branching operator ($\branchop$)
expresses that the last worker may only request more work if there are no
ongoing jobs.

To accommodate sharing of the channel endpoint between all workers using a lock
invariant, we extend the authoritative contribution ghost theory from
\Cref{sec:locks}.
We do this by adding multisets $X$ and $Y$ to the connectives
$\serverpred \gname n X$ and $\clientpred \gname Y$.
These multisets keep track of the values held by the workers.
The rules for the ghost theory extended with multisets are shown in
\Cref{fig:authM}.
The rules \ruleref{AuthM-init}, \ruleref{AuthM-alloc} and \ruleref{AuthM-dealloc}
are straightforward generalisations of the ones we have seen before.
The new rules \ruleref{AuthM-add} and \ruleref{AuthM-remove} determine that the
multiset $Y$ of $\clientpred \gname Y$ can be updated as long as it is done in
accordance with the multiset $X$ of $\serverpred \gname n X$.
Finally, the \ruleref{AuthM-contrib-agree} rule expresses that the
multiset $Y$ of $\clientpred \gname Y$ must be a subset of the
multiset $X$ of $\serverpred \gname n X$,
while the stricter rule \ruleref{AuthM-contrib-agree1} asserts equality between
$X$ and $Y$ when only one contribution remains.

The specifications of $\parmapperworkername$ and a possible
top-level client $\parmapperclientname$ that uses $n$
workers to map $\vmapvar$ over the linked list $\loc$ are as follows:
\[
\begin{array}{l l @{}}
\hoareV
  {\begin{array}{@{\,} l @{}}
     \mapspecname\
     \interpvar_\tvar\
     \interpvar_\tvarB\
     \mapvar\ \vmapvar *
     \clientpred \gname \emptyset\ *\\
     \islock \lockvar {\left(
       \begin{array}{@{} l @{} l @{}}
         \Exists n\ X.
         \serverpred \gname n X\ * \\
         \interp \chan {\dual{\parmapperprotname\
         \interpvar_\tvar\ \interpvar_\tvarB\ \mapvar\ n\ X}}
       \end{array}\right)}
     \end{array}}
  {\parmapperworkername\ \vmapvar\ \lockvar\ \chan}
  \TRUE
&
\hoareV
  {\begin{array}{@{\,} l @{\;}}
     \mapspecname\
     \interpvar_\tvar\
     \interpvar_\tvarB\
     \mapvar\ \vmapvar\ * \\
     0 < n *
     \listrefI {\interpvar_\tvar} \loc {\vec\var}
   \end{array}}
  {\parmapperclientname\ n\ \vmapvar\ \loc}
  {\Exists \vec\varB.
    \vec\varB \perm \flatmapname\ \mapvar\ \vec\var *
    \listrefI{\interpvar_\tvarB} \loc {\vec\varB}}
\end{array}
\]

\noindent
The lock invariant and specification of $\parmapperworkername$ are similar to
those used in the simple example in \Cref{sec:locks}.
The specification of $\parmapperclientname\ n\ \vmapvar\ \loc$ simply states
that the resulting linked list points to a permutation of performing the
map at the level of the logic.
To specify that, we make use of $\flatmapname :
  (\tvar \to \List\ \tvarB) \to (\List\ \tvar \to \List\ \tvarB)$, whose
definition is standard.

The proof of the client involves allocating the channel with the protocol
$\parmapperprotname$, with the initial number of workers $n$.
Subsequently, we use the rules \ruleref{AuthM-init} and \ruleref{AuthM-alloc}
to create the authority $\serverpred \gname n \emptyset$ and $n$ tokens
$\clientpred \gname \emptyset$, which allow us to establish the lock invariant
and to distribute the tokens among the mappers.
The proof of the mapper proceeds as usual.
After acquiring the lock, the mapper obtains ownership of the lock invariant.
Since the worker owns the token $\clientpred \gname \emptyset$, it knows that
the number of remaining workers $n$ is positive, which allows it to conclude
that the protocol has not terminated (\ie is not $\protend$).
After using the rules for channels, the rules \ruleref{AuthM-add} and
\ruleref{AuthM-remove} are used to update the authority, which is needed to
reestablish the lock invariant so the lock can be released.
