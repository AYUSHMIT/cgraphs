\section{A tour of \lname}
\label{sec:tour}

This section demonstrates the core features of \lname.
We first introduce the language (\Cref{sec:language}) and the logic
(\Cref{sec:logic}).
We then introduce and iteratively extend a simple distributed merge sort algorithm to
demonstrate the main features of \lname (\Cref{sec:basics}--\Cref{sec:dependent}).
Note that as the point of the sorting algorithms is to showcase the features
of \lname, they are intentionally kept simple and no effort has been made
to make them efficient (\eg to avoid spawning threads for small jobs).

\subsection{The \lname language}
\label{sec:language}

The language used throughout the paper is an untyped functional language with
higher-order functions, higher-order mutable references, fork-based
concurrency, and primitives for message-passing over bidirectional asynchronous
channels.
The syntax is as follows:
%
\begin{align*}
\val \in \Val \bnfdef{}&
  \TT \mid
  i \mid
  b \mid
  \loc \mid
  \chan \mid
  \Rec f x = \expr \mid \ldots &
  \hspace{-6em} (i \in \integer, b \in \bool, \loc \in \Loc, \chan \in \Chan) \\
\expr \in \Expr \bnfdef{}&
  \val \mid
  \var \mid
  \Rec f x = \expr \mid
  \expr_1(\expr_2) \mid
  \newref\expr \mid
  \deref \expr \mid
  \expr_1 \gets \expr_2 \mid \\ &
  \Fork \expr \mid
  \newchan \mid \send{\expr_1}{\expr_2} \mid \recv{\expr} \mid \ldots
\end{align*}

\noindent
We omit the usual operations on pairs, sums, lists, and integers, which are standard.
We introduce the following syntactic sugar:
lambda abstractions $\Lam \var. \expr$ are defined as $\Rec \_ \var = \expr$,
let-bindings $\Let \var = \expr_1 in \expr_2$ are defined as $(\Lam \var. \expr_2)\ \expr_1$,
and sequencing $\expr_1 ; \expr_2$ is defined as $\Let \_ = \expr_1 in \expr_2$.
Here, the underscore $\_$ is an anonymous binder, \ie an arbitrary variable
that is fresh in the body of the binding expression.

The language features the usual operations for heap manipulation.
New references can be created using $\newref \expr$, dereferenced using $\deref \expr$,
and assigned to using $\expr_1 \gets \expr_2$.
Concurrency is supported via $\Fork \expr$, which spawns a new thread $\expr$
that is executed in the background.
The language also supports atomic operations like compare-and-set ($\CAS$), which can be
used to implement lock-free data structures and
synchronisation primitives, but these are omitted from the syntax.

Message passing is performed over bidirectional channels, which are
represented using pairs of buffers $(\vec\val_1,\vec\val_2)$
of unbounded size.
The $\newchan$ operation creates a new channel
whose buffers are empty, and returns a tuple of endpoints $(\chan_1,\chan_2)$.
Bidirectionality is obtained by having one endpoint receive from the others
send buffer and \viceversa.
That means, $\send {\chan_i} \val$ enqueues the value $\val$ in its own
buffer, \ie $\vec\val_i$,
and $\recv {\chan_i}$ dequeues a value from the other buffer, \ie from
$\vec\val_{2}$ if $i=1$ and from $\vec\val_{1}$ if $i=2$.
Message passing is asynchronous, meaning that $\send \chan \val$ will always
reduce, while $\recv \chan$ will block as long as the receiving buffer is empty.
The exact semantics of the channels will be detailed in
\Cref{sec:semantics}.

Throughout the paper, we often use the following syntactic sugar to encapsulate
the common behaviour of starting a new process:
\[
\start{\expr}
  \eqdef
  \Let f = \expr in \Let{(\chan,\chan')} = \newchan in \Fork{f\ \chan'};\ \chan
\]
Here, $\expr$ should evaluate to a function that takes a channel endpoint.

\subsection{The \lname logic}
\label{sec:logic}

\newcommand{\logicfig}{
\begin{figure}
\centering
\textbf{Grammar:}
\begin{align*}
\type, \typeB \bnfdef{} &
  \var \mid 0 \mid 1 \mid \bool \mid \nat \mid \integer \mid \Type \mid
  \All \var : \type.\typeB \mid \\
 & \Loc \mid \Chan \mid \Val \mid \Expr \mid \iProp \mid \iProto \mid \ldots \\
\term , \termB , \iprop , \ipropB, \prot \bnfdef{}&
   \var \mid \Lam \var : \type . \term \mid
    \term (\termB) \mid \term (\type) \mid
    \tag{Polymorphic lambda-calculus}
    \\
  & \TRUE \mid \FALSE \mid \iprop \wedge \ipropB \mid
     \iprop \vee \ipropB \mid \iprop \Ra \ipropB \mid
     \tag{Propositional logic}
     \\
  & \All \var : \type. \iprop \mid \Exists \var : \type. \iprop \mid
     \term = \termB \mid
     \tag{Higher-order logic with equality}
     \\
  & \MU \var : \type . \term \mid \later \iprop \mid
    \tag{Guarded recursion}
    \\
  & \iprop * \ipropB \mid \iprop \wand \ipropB \mid \loc \mapsto \val \mid
     \hoare{\iprop}{\expr}{\Ret{\val}. \ipropB} \mid
     \tag{Separation logic}
     \\
  & \interp{\chan}{\prot} \mid \subprot{\prot_1}{\prot_2} \mid
    \dual{\prot} \mid \protapp{\prot_1}{\prot_2} \mid \protend \\
  & \sendprot{\xdots}{\val}{\iprop}{\prot} \mid
    \recvprot{\xdots}{\val}{\iprop}{\prot} \mid \ldots
    \tag{\PnameAbbr}
\end{align*}

\smallskip
\textbf{Ordinary affine separation logic:}
\begin{mathpar}
\axiomH{Affine}{\iprop * \ipropB \Ra \iprop}
\quad
\inferH{Ht-frame}
  {\hoare{\iprop}\expr{\Ret\valB. \ipropB}}
  {\hoare{\iprop * \ipropC}\expr{\Ret\valB. \ipropB * \ipropC}}
\quad
\axiomH{Ht-val}
  {\hoare\TRUE\val{\Ret \valB. \valB = \val}}
\quad
\inferH{Ht-fork}
  {\hoare{\iprop}{\expr}{\TRUE}}
  {\hoare{\iprop}{\Fork\expr}{\Ret \valB. \valB = \TT}}
\and
\inferrule*[lab=\textlabel{Ht-bind}{Ht-bind},right=\textnormal{$\lctx$ a call-by-value evaluation context}]
  {\hoare{\iprop}{\expr}{\Ret\val. \ipropB} \and
    \All \val. \hoare{\ipropB}{\fillctx \lctx[\val]}{\Ret\valB. \ipropC}}
  {\hoare{\iprop}{\fillctx \lctx[\expr]}{\Ret\valB. \ipropC}}
\end{mathpar}

\smallskip
\textbf{Recursion:}
\begin{mathpar}
\inferH{Ht-rec}
  {\hoare{\later\iprop}{\subst {\subst \expr x \val} f {\Rec f x = \expr}}{\Ret \valB. \ipropB}}
  {\hoare{\iprop}{(\Rec f x = \expr)\; \val}{\Ret \valB. \ipropB}}
\quad
\inferhref{$\later$-intro}{Later-intro}
  {}
  {\iprop \Ra \later\iprop}
\quad
\inferhref{L\"ob}{Loeb}
  {}
  {(\later\iprop\Ra\iprop) \Ra \iprop}
\quad
\inferhref{$\mu$-unfold}{rec-unfold}
  {}
  {(\MU \var.\term) = \subst \term \var {\MU \var.\term}}
\end{mathpar}

\smallskip
\textbf{Heap manipulation:}
\begin{mathpar}
\axiomH{Ht-alloc} {\hoare{\TRUE}{\newref{\val}}{\Ret \loc. \loc \mapsto \val}}
\and
\axiomH{Ht-load} {\hoare{\loc \mapsto \val}{\deref\loc}
  {\Ret \valB. (\valB = \val) * \loc \mapsto \val}}
\and
\axiomH{Ht-store} {\hoare{\loc \mapsto \val}{\loc\gets\valB}{\loc \mapsto \valB}}
\end{mathpar}

\smallskip
\textbf{Message passing:}
\begin{align*}
\hoare
  {\TRUE}
  {&\newchan}
  {\Ret{(\chan,\chan')}.
    \interp{\chan}{\prot} * \interp{\chan'}{\dual{\prot}}}
  \tagH{Ht-new} \\
\hspace{-0.5em}\hoare
  {\interp{\chan\!}{\!\sendprot{\xdots}{\val}{\iprop}{\prot}} * \subst\iprop{\vec \var}{\vec\term}}
  {&\send{\chan}{(\subst\val{\vec\var}{\vec\term})}}
  {\interp{\chan\!}{\!\subst\prot{\vec\var}{\vec\term}}}
  \tagH{Ht-send} \\
\curlybracket{\interp{\chan\!}{\!\recvprot{\xdots}{\val}{\iprop}{\prot}}}\spac &\recv{\chan} \spac \{ \Ret \valB. \Exists \vec\varB.
    \begin{array}[t]{@{} l @{}}
      (\valB \!=\! \subst\val{\vec \var}{\vec\varB})\ * \\
    \interp{\chan\!}{\!\subst\prot{\vec \var}{\vec\varB}} *
    \subst\iprop{\vec \var}{\vec\varB} \} \end{array}
      \hspace{-0.4em}
  \tagH{Ht-recv}
\end{align*}

\smallskip
\textbf{\Pname:}
\[\begin{aligned}
  \dual{\sendprot{\xdots}{\val}{\iprop}{\prot}} ={}& \recvprot{\xdots}{\val}{\iprop}{\dual{\prot}} \\
  \dual{\recvprot{\xdots}{\val}{\iprop}{\prot}} ={}& \sendprot{\xdots}{\val}{\iprop}{\dual{\prot}} \\
  \protapp{(\sendprot{\xdots}{\val}{\iprop}{\prot_1})}{\prot_2} ={}&
  \sendprot{\xdots}{\val}{\iprop}{(\protapp{\prot_1}{\prot_2})} \\
  \protapp{(\recvprot{\xdots}{\val}{\iprop}{\prot_1})}{\prot_2} ={}&
  \recvprot{\xdots}{\val}{\iprop}{(\protapp{\prot_1}{\prot_2})} \\
  \protapp{\prot_1}{(\protapp{\prot_2}{\prot_3})} ={}& \protapp{(\protapp{\prot_1}{\prot_2})}{\prot_3}\\
\end{aligned}
\quad
\begin{aligned}
  \dual{\protend} ={}& \protend \\
  \dual{\dual{\prot}} ={}& \prot \\
  \protapp\prot\protend ={}& \prot \\
  \protapp\protend\prot ={}& \prot \\
  \dual{\protapp{\prot_1}{\prot_2}} ={}& \protapp{\dual{\prot_1}}{\dual{\prot_2}}
\end{aligned}\]
\caption{The grammar and a selection of rules of \lname.}
\label{fig:logic}
\end{figure}
}

\logicfig

\lname is a higher-order impredicative concurrent separation logic with a
new notion called \emph{\pname} to reason about message-passing concurrency.
As we will show in \Cref{sec:model}, \lname is built as a library on top of the Iris
framework \cite{jung-POPL2015,krebbers-ESOP2017,jung-ICFP06,jung-JFP2018} and
thus inherits all features of Iris.
For the purpose of this section, no prior knowledge of Iris is expected
as the majority of Iris's features are orthogonal to Actris's.
At this point, we are primarily concerned with Iris's support for nested Hoare
triples and guarded recursion, which we need to transfer functions over channels
(\Cref{sec:functions}) and to define recursive protocols
(\Cref{sec:rec}).
An extensive overview of Iris can be found in \cite{jung-JFP2018}, and a
tutorial-style introduction can be found in \cite{lecturenotes}.

The grammar of \lname and a selection of its rules are displayed in
\Cref{fig:logic}.
The \lname grammar includes the polymorphic lambda-calculus\footnote{\lname
and Iris, which are both formalised as a shallow embedding in Coq, have in fact
a predicative $\Type$ hierarchy, while propositions $\iProp$ are impredicative.
For brevity's sake, we omit details about predicativity of $\Type$, as they are
standard.}
with a number of primitive types and terms operating on these types.
Most important is the type $\iProp$ of propositions and the type $\iProto$ of
\pname.
The typing judgement is mostly standard and can be derived from the use of
meta variables---we use the meta variables $\iprop$ and $\ipropB$ for propositions,
the meta variable $\prot$ for protocols,
the meta variable $\val$ for values,
and the meta variables $\term$ and $\termB$ for general terms of any type.
Apart from that, there is the implicit side-condition that recursive
predicates defined using the recursion operator $\MU \var:\type. \term$ should be
\emph{guarded}.
That means, the variable $\var$ should appear under a \emph{contractive} term
construct.
As is usual in logics with guarded recursion~\cite{nakano-LICS2000}, the later
$\later$ modality is contractive and is used to define recursive predicates.
But moreover, as we will demonstrate in \Cref{sec:rec}, the constructors
$\sendprot {\xdots} \val \iprop \prot$ and $\recvprot {\xdots} \val \iprop \prot$
of \pname are contractive in the tail argument $\prot$ to enable the
construction of recursive protocols.
The rule \ruleref{rec-unfold} says that $\MU \var:\type. \term$ is in fact
a fixpoint of $\term$.

To express program specifications, \lname features Hoare triples
$\hoare \iprop \expr {\Ret \val.\ipropB}$, where $\iprop$ is the precondition and
$\ipropB$ the postcondition.
The binder $\val$ can be used to talk about the return value of $\expr$ in
the postcondition $\ipropB$, but is omitted if the result is~$\TT$.
Note that Hoare triples are propositions of the logic themselves (\ie they
are of type $\iProp$), so they can be nested to express specifications of
higher-order functions.
The rules for Hoare triples are mostly standard, but it is worth pointing out
the rule \ruleref{Ht-rec} for recursive functions.
This rule has a later modality ($\later$) in the precondition, which when combined
with the \ruleref{Loeb} rule allows reasoning about general recursive functions.
As usual, the \emph{points-to} connective
$\loc \mapsto \val$ expresses unique ownership of a location $\loc$ with
value $\val$.
Since we consider a garbage collected language,
arbitrary separation logic resources can be discarded via the rule \ruleref{Affine}.

The novel feature of \lname is its support for \pname to reason about
message-passing programs.
This is done using the $\interp \chan \prot$ connective, which expresses unique
ownership of a channel endpoint $\chan$ and states that the endpoint follows
the protocol $\prot$.
\Pname $\prot$ are streams of
$\sendprot {\xdots} \val \iprop \prot$ and
$\recvprot {\xdots} \val \iprop \prot$ constructors that are either infinite or finite.
The finite streams are ultimately terminated by an $\protend$ constructor.
The value $\val$ denotes the message that is being sent ($\SEND$) or received
($\RECV$), the proposition $\iprop$ denotes the ownership that is transferred
along the message, and $\prot$ denotes the protocol that describes the subsequent
messages.
The logical variables $\xdots$ can be used to bind variables in $\val$, $\iprop$,
and $\prot$.
For example, $\sendprot{(b:\bool)\,(\loc:\Loc)\,(i:\nat)}{(b,\loc)}
  {\loc \mapsto i * 10 < i} \prot$ expresses that a pair of a boolean and an
integer reference whose value is at least 10 is sent.
We often omit the proposition $\curlybracket{\iprop}$, which simply means it is
$\TRUE$.

Apart from the constructors for \pname, \lname provides two primitive
operations.
The $\dual{\prot}$ connective denotes the \emph{dual} of a protocol.
As with conventional session types, it transforms the protocol by changing all
sends ($\SEND$) into receives ($\RECV$), and \viceversa.
Taking the dual twice thus results in the original protocol.
The connective $\protapp{\prot_1}{\prot_2}$ \emph{appends} the protocols $\prot_1$
and $\prot_2$, which is achieved by substituting any $\protend$ in $\prot_1$
with $\prot_2$.
Finally, $\subprot{\prot_1}{\prot_2}$ states that the
protocol $\prot_1$ is a \emph{subprotocol} of $\prot_2$.
The subprotocol relation and its proof rules will be described in
\Cref{sec:subprotocols}.

The rule \ruleref{Ht-new} allow ascribing any protocol to newly created
channels using $\newchan$, obtaining ownership of $\interp \chan \prot$ and
$\interp {\chan'} {\dual \prot}$ for the respective endpoints.
The duality of the protocol guarantees that any receive ($\RECV$) is matched with a
send ($\SEND$) by the dual endpoint, which is crucial for establishing safety (\ie
session fidelity, see \Cref{sec:adequacy}).

The rule \ruleref{Ht-send} for $\send \chan \valB$ requires the head of the
\pnameSingular of $\chan$ to be a send ($\SEND$) constructor, and
the value $\valB$ that is send to match up with the ascribed value.
To send a message $\valB$, we need to give up ownership of
$\interp{\chan}{\sendprot{\xdots}{\val}{\iprop}{\prot}}$,
pick an appropriate instantiation $\vec\term$ for the variables
$\xdots$ so that $\valB = \subst\val{\vec\var}{\vec\term}$,
give up ownership of the associated resources $\subst\iprop{\vec \var}{\vec\term}$,
and finally regain ownership of the protocol tail
$\interp{\chan}{\subst\prot{\vec\var}{\vec\term}}$.

The rule \ruleref{Ht-recv} for $\recv \chan$ is essentially dual to the rule
\ruleref{Ht-send}.
We need to give up ownership of
$\interp{\chan}{\recvprot{\xdots}{\val}{\iprop}{\prot}}$, and
in return acquire the resources $\subst\iprop{\vec \var}{\vec\varB}$,
the return value $\valB$ where $\valB = \subst\val{\vec\var}{\vec\varB}$,
and finally the ownership of the protocol tail
$\interp{\chan}{\subst\prot{\vec \var}{\vec\varB}}$,
where $\vec\varB$ are instances of the variables of the protocol.

\subsection{Basic protocols}
\label{sec:basics}

\newcommand{\sortfigure}{
\begin{figure}
\begin{equation*}
\begin{array}{ll}
\begin{array}[t]{@{}l@{\qquad}}
\listsortservicename\ \cmpvar\ \chan\ \eqdef\\
\quad \Let l = \recv \chan in\\
\quad \If \listlength{l} \le 1 then \send \chan \TT \Else\\
\quad \Let l' = \mathtt{split}\ l in\\
\quad \Let \chan_1 = \start{\listsortservicename\ \cmpvar} in\\
\quad \Let \chan_2 = \start{\listsortservicename\ \cmpvar} in\\
\quad \send {\chan_1} l;\ \send{\chan_2}{l'};\\
\quad \recv {\chan_1};\ \recv {\chan_2};\\
\quad \mathtt{merge}\ \mathit{\cmpvar}\ l\ l';\ \send \chan \TT
\end{array}
&
\begin{array}[t]{@{}l}
\listsortclientname\ \cmpvar\ l \eqdef \\
\quad \Let \chan = \start{\listsortservicename\ \cmpvar} in \\
\quad \send \chan l;\\
\quad \recv \chan
\end{array}
\end{array}
\end{equation*}
\caption{A distributed merge sort algorithm
(the code for $\mathtt{merge}$ and $\mathtt{split}$ is standard and thus elided).}
\label{fig:sort}
\end{figure}}

In order to show the basic features of \pname, we will prove the functional
correctness of a simple distributed merge sort algorithm, whose code is shown
in \Cref{fig:sort}.

\sortfigure

The function $\listsortclientname$ takes a comparison function $\cmpvar$ and a
reference to a linked list $\mathit{l}$ that will be sorted using merge sort.
The bulk of the work is done by the $\listsortservicename$ function that is
parameterised by a channel $\chan$ over which it receives a reference to the
linked list to be sorted.
If the list is an empty or singleton list, which is trivially sorted, the
function immediately sends back a unit value $\TT$ to inform the caller that
the work has been completed, and terminates.
Otherwise, the list is split into two partitions using the $\mathtt{split}$
function, which updates the list in-place so that $\loc$ points to the first
partition, and returns a reference $l'$ to the second partition.
These partitions are recursively sorted using two newly started instances of
$\listsortservicename$.
The results of the processes are then requested and merged using the $\mathtt{merge}$
function, which updates the list in-place so that $l$ points to the merged list.
Finally, the unit value $\TT$ is sent back along the original channel $\chan$.

In order to verify the correctness of the sorting algorithm we first need a
specification for the comparison function $\cmpvar$, which must satisfy the
following specification:
\begin{equation*}
\begin{array}{l}
\cmpspecname\ (\interpvar : \tvar \to \Val \to \iProp)
  \ (\relvar : \tvar \to \tvar \to \bool)\ (\cmpvar : \Val) \eqdef \\
\quad\quad\quad(\All \var_1\,\var_2. \relvar\ \var_1\ \var_2 \lor \relvar\ \var_2\ \var_1) \land{} \\
\quad\quad\quad(\All \var_1\,\var_2\,\val_1\,\val_2.
  \hoare{\interpvar\ \var_1\ \val_1 * \interpvar\ \var_2\ \val_2}
    {\cmpvar\ \val_1\ \val_2}
    {\Ret r. r = \relvar\ \var_1\ \var_2 * I\ \var_1\ \val_1 * I\ \var_2\ \val_2})
\end{array}
\end{equation*}

\noindent Here, $\relvar$ is a decidable total relation on an implicit polymorphic type
$\tvar$, and $\interpvar$ is an interpretation predicate that relates language
values to elements of type $\tvar$.
While the relation $\relvar$ dictates the ordering, the interpretation predicate
$\interpvar$ allows for flexibility about what is ordered.
Setting $\interpvar$ to \eg $\Lam \var\;\val. \val \mapsto \var$
orders references by what they point to in memory, rather than the memory address
itself.
To specify how lists are laid out in memory we use the following notation:
\begin{equation*}
\listrefI \interpvar \loc {\vec \var} \eqdef
  \begin{cases}
  \loc \mapsto \Inl\;\TT & \textnormal{if $\vec\var = \nil$} \\
  \Exists \val_1\;\loc_2.
    \loc \mapsto \Inr\;(\val_1,\loc_2) * \interpvar\ \var_1\ \val_1 *
    \listrefI \interpvar {\loc_2} {\vec\var_2}
    & \textnormal{if $\vec\var = [\var_1] \cdot \vec\var_2$}
  \end{cases}
\end{equation*}

\noindent
The channel $\chan$ adheres to the following \pnameSingular:
\begin{equation*}
\begin{array}{l}
\listsortprotname\ (\interpvar : \tvar \to \Val \to \Prop)
\ (\relvar : \tvar \to \tvar \to \bool) \eqdef \\
\qquad
  \sendprot{(\vec{\var}:\List\ \tvar)\;(\loc : \Loc)}{\loc}
  {\listrefI \interpvar \loc {\vec\var}}{
\recvprot{\vec{\varB}}{\TT}
  {\listrefI \interpvar \loc {\vec \varB} *
   \sortedof {\vec\varB} {\vec\var} \relvar}{
      \protend}}
\end{array}
\end{equation*}

\noindent
The protocol describes the interaction of sending a list reference, and then
receiving a unit value $\TT$ once the list is sorted and the reference is
updated to point to the sorted list.
The predicate $\sortedof {\vec\varB} {\vec\var} \relvar$
is true iff $\vec\varB$ is a sorted version of $\vec\var$ with respect to
the relation $\relvar$.
The specification of the service and the client is as follows:
\[
\begin{array}{c !{\quad} c}
\begin{array}{l}
  \hoareV
    {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
     \interp{\chan}{\protapp{\dual{\listsortprotname\ \interpvar\ \relvar}} \prot}}
    {\listsortservicename\ \cmpvar\ \chan}
    {\interp{\chan}{\prot}}
\end{array}
  &
\begin{array}{l}
  \hoareV
    {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
     \listrefI \interpvar \loc {\vec\var}}
    {\listsortclientname\ \cmpvar\ \loc}
    {\Exists \vec\varB.
     \sortedof {\vec\varB} {\vec\var} \relvar *
     \listrefI \interpvar \loc {\vec\varB}}
\end{array}
\end{array}
\]
\noindent
There are two important things to note about these specifications.
First, the protocol $\listsortprotname$ is written from the point of view
of the client.
As such, the precondition for $\listsortservicename$ requires that $\chan$
follows the dual.
Second, the pre- and postcondition of $\listsortservicename$ are generalised
to have an arbitrary protocol $\prot$ appended at the end.
It is important to write specifications this way, so they can be embedded in
other protocols.
We will see examples of that in \Cref{sec:rec} and~\Cref{sec:delegation}.

The proof of these specifications is almost entirely performed by symbolic
execution using the rules \ruleref{Ht-new}, \ruleref{Ht-send},
\ruleref{Ht-recv}, and the standard separation logic rules.

\subsection{Transferring functions}
\label{sec:functions}

\newcommand{\sendfuncfig}{
\begin{figure}
\begin{equation*}
\begin{array}{@{}l@{\qquad}l@{}}
\begin{array}[t]{@{}l@{}}
  \listsortcmpservicename\ \chan \eqdef \\
  \quad \Let \cmpvar = \recv \chan in\\
  \quad \listsortservicename\ \cmpvar\ \chan
\end{array}
&
\begin{array}[t]{@{}l@{}}
  \listsortcmpclientname\ \cmpvar\ l \eqdef \\
  \quad
  \Let \chan = \start\listsortcmpservicename in\\
  \quad
  \send \chan \cmpvar;\
  \send \chan l;\ \recv \chan
\end{array}
\end{array}
\end{equation*}
\caption{A version of the sort service that receives the comparison function
over the channel.}
\label{fig:sendFunction}
\end{figure}}

\sendfuncfig

The distributed $\listsortservicename$ from the previous section
(\Cref{fig:sort}) is parametric on a comparison function.
To demonstrate \lname's support for reasoning about functions transferred over
channels, we verify the correctness of the program $\listsortcmpservicename$ in
\Cref{fig:sendFunction}, which receives the comparison function over the
channel instead of via a lambda abstraction.
To verify this program, we extend the protocol $\listsortprotname$ from
\Cref{sec:basics} as follows:
\begin{align*}
\listsortcmpprotname \eqdef{}& \SEND
    (\tvar : \Type)\ (\interpvar : \tvar \to \Val \to \Prop)\
    (\relvar : \tvar \to T \to \bool)\ (\cmpvar: \Val)\\
  & \quad \langle \cmpvar \rangle
  \curlybracket{\cmpspecname\ \interpvar\ \relvar\ \cmpvar}.\,
  \listsortprotname\ \interpvar\ \relvar
\end{align*}
%
The new protocol captures that we first send a comparison function $\cmpvar$.
It includes binders for the polymorphic type $\tvar$, the
interpretation predicate $\interpvar$, and the relation $\relvar$.
The specifications are much the same as before, with the proofs being similar
besides the addition of a symbolic execution step to resolve the sending and
receiving of the comparison function:
\[
\begin{array}{c !{\quad} c}
\begin{array}{l}
  \hoareV
    {\interp \chan {\protapp {\dual{\listsortcmpprotname}} \prot}}
    {\listsortcmpservicename\ \chan}
    {\interp \chan \prot}
\end{array}
  &
\begin{array}{l}
\hoareV
  {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
   \listrefI \interpvar \loc {\vec\var}}
  {\listsortcmpclientname\ \cmpvar\ \loc}
  {\Exists \vec\varB.
   \listrefI \interpvar \loc {\vec\varB} *
   \sortedof {\vec\varB} {\vec\var} \relvar}
\end{array}
\end{array}
\]

\subsection{Choice}
\label{sec:choice}

Branching communication is commonly modelled using the \emph{choice} session types
$\branchop$ for branching and $\selectop$ for selection.
We show that corresponding \pname can readily be encoded in \lname.
At the level of the programming language, the instructions for choice are
encoded by sending and receiving a boolean value that is matched using an if-then-else construct:
\begin{align*}
\select \expr \expr' \eqdef{}&
  \send \expr \expr' \\
\branchA \expr {\expr_1} {\expr_2} \eqdef{}&
  \If \recv \expr then \expr_1 \Else \expr_2
\end{align*}

\noindent
We let $\leftname \eqdef \True$ and $\rightname \eqdef \False$ to be used
together with $\langkw{select}$ for readability's sake.
Due to the higher-order nature of \lname, the usual protocol specifications for
choice from session types can be encoded as regular logical branching within
the protocols:
\begin{align*}
\selectprotprop{\prot_1}{\ipropB_1}{\ipropB_2}{\prot_2} \eqdef{}&
  \sendprot {(b:\bool)} b {\If b then \ipropB_1 \Else \ipropB_2}
                {\If b then \prot_1 \Else \prot_2} \\
\branchprotprop{\prot_1}{\ipropB_1}{\ipropB_2}{\prot_2} \eqdef{}&
  \recvprot {(b:\bool)} b {\If b then \ipropB_1 \Else \ipropB_2}
                {\If b then \prot_1 \Else \prot_2}
\end{align*}

\noindent
We often omit the conditions $\ipropB_1$ and $\ipropB_2$, which simply means
that they are $\TRUE$.
The following rules can be directly derived from the rules
\ruleref{Ht-send} and \ruleref{Ht-recv}:
%
\begin{mathparpagebreakable}
\axiomH{Ht-select}{\hoare
  {\begin{array}{@{}l@{}}
     \interp{\chan}{\selectprotprop{\prot_1\!}{\ipropB_1}{\ipropB_2}{\!\prot_2}}\ * \\\ite{b}{\ipropB_1}{\ipropB_2}
     \end{array}}
  {\select{\chan}{b}}
  {\interp{\chan}{\ite{b}{\prot_1}{\prot_2}}}}
\and
\inferH{Ht-branch}
  {\hoare
    {\iprop * \ipropB_1 * \interp{\chan}{\prot_1}}
    {\expr_1}
    {\Ret \val. \ipropC} \and
   \hoare
    {\iprop * \ipropB_2 * \interp{\chan}{\prot_2}}
    {\expr_2}
    {\Ret \val. \ipropC}}
  {\hoare
    {\iprop * \interp{\chan}{\branchprotprop{\prot_1}{\ipropB_1}{\ipropB_2}{\prot_2}}}
    {\branchA{\chan}{\expr_1}{\expr_2}}
    {\Ret \val. \ipropC}}
\end{mathparpagebreakable}

\noindent
Apart from branching on boolean values, \pname can be used to encode
choice on any enumeration type (\eg lists, natural numbers, days of the
week, \etc).
These encodings follow the same scheme.

\subsection{Recursive protocols}
\label{sec:rec}

\newcommand{\loopsortfig}{
\begin{figure}[t!]
\begin{equation*}
\begin{array}{l l}
\begin{array}[t]{@{}l@{}}
\listsortloopservicename\ \cmpvar\ \chan \eqdef \\
\quad\begin{array}[t]{@{}l@{}}
  \mbranchA \chan
  {\begin{array}[t]{@{} l}
     \listsortservicename\ \cmpvar\ \chan;\ \\
     \listsortloopservicename\ \cmpvar\ \chan
   \end{array}}
  \TT \\
\end{array}
\end{array}
&
\begin{array}[t]{@{}l@{}}
  \listsortloopclientname\ \cmpvar\ l \eqdef \\
  \quad \Let \chan = \start {\listsortloopservicename\ \cmpvar} in \\
  \quad \defemph{iter}\ (\Lam l'. \select \chan \leftname;\ \send \chan {l'};\ \recv \chan)\ l; \\
  \quad \select \chan \rightname
\end{array}
\end{array}
\end{equation*}
\caption{A recursive version of the sort service that can perform multiple jobs in sequence
(the code for the function $\defemph{iter}$, which applies a function to each
element of the list, is standard and has been elided).}
\label{fig:loopservice}
\end{figure}
}

We will now use choice and recursion to verify the correctness
of a sorting service that supports performing multiple sorting jobs in sequence.
The code of the sorting service $\listsortloopservicename$ and a possible
client $\listsortloopclientname$ are displayed in \Cref{fig:loopservice}.
The service $\listsortloopservicename$ contains a loop in which choice is
used to either terminate the service, or to sort an individual list using the
distributed merge sort algorithm $\listsortservicename$ from \Cref{sec:basics}.
The client $\listsortloopclientname$ uses the service to sort a nested linked
list $l$ of linked lists.
It performs this job by starting a single instance of the service at $\chan$, and then
sequentially sends requests to sort each inner linked list $l'$ in $l$.
Finally, the client selects the terminating branch to end the communication with
the service.
A protocol for interacting with the sorting service can be defined as follows:

\loopsortfig

\begin{equation*}
\begin{array}{l}
\listsortloopprotname\ (\interpvar : \tvar \to \Val \to \Prop)
\ (\relvar : \tvar \to \tvar \to \bool) \eqdef{} \\
\qquad\qquad\qquad\qquad \MU (\recvar : \iProto).
  \selectprot
    {(\protapp {\listsortprotname\ \interpvar\ \relvar} \recvar)}
    \protend
\end{array}
\end{equation*}

\noindent
The protocol uses the choice operator $\selectop$ to specify that the client
may either request the service to perform a sorting job, or terminate
communication with the service.
After the job has been finished the protocol proceeds
recursively.

It is important to point out that---as is usual in logics with guarded recursion
\cite{nakano-LICS2000}---the variable $\var$ should appear under a
\emph{contractive} term construct in the body $\term$ of $\MU \var:\type.\term$.
In our protocol, the recursive variable $\recvar$ appears under the argument of
$\selectop$, which is defined in terms of $\sendprot {\xdots} \val \iprop \prot$,
which, similarly to $\recvprot {\xdots} \val \iprop \prot$, is contractive in the
tail protocol $\prot$.
The specifications of the service and the client are as follows:
\[
\begin{array}{c !{\quad} c}
\begin{array}{l}
\hoareV
  {\begin{array}{@{} l}
   \cmpspecname\ \interpvar\ \relvar\ \cmpvar\ *\\
   \interp \chan {\protapp {\dual\listsortloopprotname} \prot}
   \end{array}}
  {\listsortloopservicename\ \cmpvar\ \chan}
  {\interp\chan \prot}
\end{array}
&
\begin{array}{l}
\hoareV
  {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
   \listrefI \interpvarB \loc {\vec{\vec\var}}}
  {\listsortloopclientname\ \cmpvar\ \loc}
  {
    \Exists \vec{\vec\varB}.
    \listlength {\vec{\vec\varB}} = \listlength {\vec{\vec\var}} *
    \listrefI \interpvarB \loc {\vec{\vec\varB}} *
    (\All i < \listlength {\vec{\vec\var}}.
      \sortedof{\vec{\vec\varB}_i} {\vec{\vec\var}_i} \relvar)}
\end{array}
\end{array}
\]

\noindent
We let $\interpvarB \eqdef \Lam \loc'\,\vec\varB. \listrefI \interpvar {\loc'} {\vec\varB}$
to express that $\loc$ points to a list of lists $\vec{\vec\var}$.
The proof of the service follows naturally by symbolic execution
using the induction hypothesis (obtained from \ruleref{Loeb}), the
rules \ruleref{Ht-branch} and \ruleref{Ht-select}, and the specification
of $\listsortservicename$.
Note that we rely on the specification of $\listsortservicename$ having an
arbitrary protocol as its suffix.

It is worth pointing out that protocols in \lname provide a lot of flexibility.
Using just minor changes, we can extend the protocol to support transferring a
comparison function over the channel, like the extension made in
$\listsortcmpclientname$,
or in a way such that a different comparison function can be used for each sorting job.

\subsection{Delegation}
\label{sec:delegation}

\newcommand{\delegationfig}{
\begin{figure}[t!]
\begin{equation*}
\begin{array}{@{}l@{\quad}l@{}}
\begin{array}[t]{@{}l@{}}
\listsortdelservicename\ \cmpvar\ \chan\ \eqdef \\
  \quad \mbranchE
     \chan
     {\begin{array}[t]{@{}l@{}}
      \Let \chan' = \start{\listsortservicename\ \cmpvar} in \\
      \send \chan {\chan'}; \\
      \listsortdelservicename\ \cmpvar\ \chan
      \end{array}}
     \TT
\end{array}
&
\begin{array}[t]{@{}l@{}}
  \listsortdelclientname\ \cmpvar\ l = \\
  \quad \Let \chan = \start{\listsortdelservicename\ \cmpvar} in \\
  \quad \Let k = \defemph{new\_list}\ \TT in \\
  \quad \begin{array}{@{}l @{} l @{}}
      \defemph{iter}\ (\Lam l'.{} & \select \chan \leftname; \\
      & \Let \chan' = \recv \chan in \\
      & \defemph{push}\ c'\ k;\ \send {\chan'} {l'})\ l
      \end{array} \\
  \quad \send \chan \rightname; \\
  \quad \defemph{iter}\ \langkw{recv}\ k\\
\end{array}
\end{array}
\end{equation*}
\caption{A recursive version of the sort service that uses delegation to perform
multiple jobs in parallel (the code for the function $\defemph{push}$,
which pushes an element to the head of a list, has been elided).}
\label{fig:delegation}
\end{figure}
}

Delegation is a common feature within communication protocols, and
particularly the session-types community---it is the concept of transferring
a channel endpoint over a channel.
Due to the impredicativity of \pname in \lname, reasoning about programs
that make use of delegation is readily available.
The protocols $\sendprot {\xdots} \val \iprop \prot$ and
$\recvprot {\xdots} \val \iprop \prot$ can simply refer to the ownership of
protocols $\interp \chan {\prot'}$ in the proposition $\iprop$.

An example of a program that uses delegation is the $\listsortdelservicename$ variant
of the recursive sorting service in \Cref{fig:delegation}, which allows
multiple sorting jobs to be performed in parallel.
To enable parallelism, it delegates a new channel $\chan'$ to an inner sorting
service for each sorting job.

The client $\listsortdelclientname$ once again uses the sorting service to sort a
nested linked list $l$ of linked lists.
The client starts a connection $\chan$ to the new service, and for each inner
list $l'$, it acquires a delegated channel $\chan'$, over which it sends a
pointer $l'$ to the inner list that should be sorted.
The client keeps track of all channels to delegated services in a linked
list $k$ so that it can wait for all of them to finish (using
$\defemph{iter}\ \langkw{recv}$).

A protocol for the delegation service can be defined as follows,
denoting that the client can select whether to acquire a
connection to a new delegated service or to terminate:
\begin{equation*}
\begin{array}{l}
\listsortdelprotname\ (\interpvar : \tvar \to \Val \to \Prop)
  \ (\relvar : \tvar \to \tvar \to \bool) \eqdef{} \\
\qquad \MU (\recvar : \iProto).
  \selectprot
    {(\recvprot {(\chan:\Chan)} \chan {\interp \chan
       {\listsortprotname\ \interpvar\ \relvar}} \recvar)}
    \protend
\end{array}
\end{equation*}

\noindent
The specifications of the service and the client are as follows:
\[
\begin{array}{c !{\quad} c}
\begin{array}{l}
\hoareV
  {\begin{array}{@{} l}
   \cmpspecname\ \interpvar\ \relvar\ \cmpvar\ *\\
   \interp \chan {\protapp {\dual\listsortdelprotname} \prot}
   \end{array}}
  {\listsortdelservicename\ \cmpvar\ \chan}
  {\interp\chan \prot}
\end{array}
&
\begin{array}{l}
\hoareV
  {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
   \listrefI \interpvarB \loc {\vec{\vec\var}}}
  {\listsortdelclientname\ \cmpvar\ \loc}
  {
    \Exists \vec{\vec\varB}.
    \listlength {\vec{\vec\varB}} = \listlength {\vec{\vec\var}} *
    \listrefI \interpvarB \loc {\vec{\vec\varB}} *
    (\All i < \listlength {\vec{\vec\var}}.
      \sortedof{\vec{\vec\varB}_i} {\vec{\vec\var}_i} \relvar)}
\end{array}
\end{array}
\]

\noindent
As before, we let $\interpvarB \eqdef \Lam \loc'\,\vec\varB. \listrefI \interpvar {\loc'} {\vec\varB}$
to express that $\loc$ points to a list of lists $\vec{\vec\var}$.
Once again the proofs are straightforward, as they are simply a combination of
recursive reasoning combined with the application of \lname's rules for channels.

\delegationfig

\subsection{Dependent protocols}
\label{sec:dependent}

\newcommand{\dependentfig}{
\begin{figure}
\begin{equation*}
\begin{array}{@{}l@{\quad}l@{}}
\begin{array}[t]{@{}l@{}}
\listsortelemservicename\ \cmpvar\ \chan\ \eqdef\\
\quad \mbranchD \chan
  {\begin{array}[t]{@{}l@{}}
    \Let \var_1 = \recv\chan in\\
    \mbranchD{\chan}
    {\begin{array}[t]{@{} l @{}}
      \Let \var_2 = \recv \chan in \\
      \Let \chan_1 = \start{\listsortelemservicename\ \cmpvar} in \\
      \Let \chan_2 = \start{\listsortelemservicename\ \cmpvar} in \\
      \select {\chan_1} \leftname;\ \send {\chan_1} \var_1; \\
      \select {\chan_2} \leftname;\ \send {\chan_2} \var_2; \\
      \listsortelemservicesplitname\ \chan\ \chan_1\ \chan_2;\
      \listsortelemservicemergename\ \cmpvar\ \chan\ \chan_1\ \chan_2
     \end{array}}
    {\begin{array}[t]{@{} l @{}}
       \select \chan \leftname;\
       \send \chan \var_1; \\
       \select \chan \rightname
     \end{array}}
    \end{array}}
  {\select \chan \rightname} \\
~ \\[-0.7em]
\listsortelemservicesplitname\ \chan\ \chan_1\ \chan_2\ \eqdef\\
\quad \mbranchD \chan
  {\begin{array}[t]{@{}l@{}}
     \Let \var = \recv \chan in \\
     \select {\chan_1} \leftname;\ \send {\chan_1} \var;\\
     \listsortelemservicesplitname\ \chan\ \chan_2\ \chan_1
   \end{array}}
  {\begin{array}[t]{@{}l@{}}
     \select {\chan_1} \rightname;\\ \select {\chan_2} \rightname
   \end{array}}
\end{array}
&
\begin{array}[t]{@{} l @{}}
\listsortelemservicemergename\ \cmpvar\ \chan\ \chan_1\ \chan_2 \eqdef\\
  \quad \mbranchD {\chan_1}
     {\begin{array}[t]{@{}l@{}}
        \Let \var = \recv {\chan_1} in \\
        \listsortelemservicemergerecname\ \cmpvar\ \chan\ \var\ \chan_1\ \chan_2
      \end{array}}
     {\Assert\ \False} \\
~ \\[-0.7em]
\listsortelemservicemergerecname\ \cmpvar\ \chan\ \var\ \chan_1\ \chan_2 \eqdef\\
\quad \mbranchD {\chan_2}
  {\begin{array}[t]{@{}l@{}}
     \Let \varB = \recv{\chan_2} in \\
     \If {\cmpvar\ \var\ \varB} then \\
       \quad \select \chan \leftname;\ \send \chan \var; \\
       \quad \listsortelemservicemergerecname\ \cmpvar\ \chan\ \varB\ \chan_2\ \chan_1 \\
     \Else \\
       \quad \select \chan \leftname;\ \send \chan \varB; \\
       \quad \listsortelemservicemergerecname\ \cmpvar\ \chan\ \var\ \chan_1\ \chan_2
   \end{array}}
  {\begin{array}[t]{@{}l@{}}
     \select{\chan}{\leftname}; \send{\chan}{\var_1}; \\
     \listsortelemservicetransfername\ \chan_1\ \chan
   \end{array}} \\
~ \\[-0.7em]
\listsortelemclientname\ \cmpvar\ l\ \eqdef\\
  \quad \Let \chan = \start{\listsortelemservicename\ \cmpvar} in\\
  \quad \sendallname\ \chan\ l;\
  \recvallname\ \chan\ l
\end{array}
\end{array}
\end{equation*}
\caption{A fine-grained version of the sort service that transfers elements one
by one (the code for the functions $\listsortelemservicetransfername$,
$\sendallname$, and $\recvallname$ has been elided).}
\label{fig:dependent}
\end{figure}
}

The protocols we have seen so far have only made limited use of \lname's support
for recursion.
We now demonstrate \lname's support for dependent protocols, which make it
possible to keep track of the history of what messages have been sent and
received.
We demonstrate this feature by considering a fine-grained version of the
distributed merge-sort service.
This version $\listsortelemservicename$, as shown in \Cref{fig:dependent},
requires the input list to be sent element by element, after which the service
sends the sorted list back in the same fashion.
We use choice to indicate whether the whole list has been
sent ($\rightname$) or another element remains to be sent ($\leftname$).

\dependentfig

The structure of $\listsortelemservicename$ is somewhat similar to the
coarse-grained merge-sort algorithm that we have seen before.
The base cases of the empty or the singleton list are handled initially.
This is achieved by waiting for at least two values before starting
the recursive sub-services $\chan_1$ and $\chan_2$.
In the base cases the values are sent back immediately, as they are trivially
sorted.
The inductive case is handled by starting two sub-services at $\chan_1$ and
$\chan_2$ that are sent the two initially received elements, respectively,
after which the $\listsortelemservicesplitname$ function is used to
receive and forward the remaining values to the sub-services alternatingly.
Once the $\rightname$ flag is received, the $\listsortelemservicesplitname$
function terminates, and the algorithm moves to the second phase in which
the $\listsortelemservicemergename$ function merges the stream of values
returned by the sub-services and forwards them to the parent service.

The $\listsortelemservicemergename$ function initially acquires the first value
$\var$ from the first sub-service, which it uses in the recursive call as the
current largest value.
The recursive function $\listsortelemservicemergerecname$ recursively requests
a value $\varB$ from the sub-service of which the current largest value was not
acquired from.
It then compares $\var$ and $\varB$ using the comparison function $\cmpvar$,
and forwards the smallest element.
This is repeated until the $\rightname$ flag is received from either sub-service,
after which the remaining values of the other are forwarded to the parent service
using the $\listsortelemservicetransfername$ function.

The interface of the client $\listsortelemclientname$ for this service is similar
to the previous ones.
It takes a reference to a linked list, which is then sorted.
It performs this task by sending the elements of the linked list to the sort
service using the $\sendallname$ function (which modifies the list in-place
by removing the sent elements), and puts the received values
back into the linked list using the $\recvallname$ function (which also modifies
the list in-place).
A suitable protocol for proving functional correctness of the fine-grained
sorting service is as follows:
%
\begin{align*}
\listsortelemprotname\; (\interpvar : \tvar \to \Val \to \Prop)
  \ (\relvar : \tvar \to \tvar \to \bool) \eqdef{}&
  \listsortelemprotheadname\ \interpvar\ \relvar\ \nil \\[0.1em]
\listsortelemprotheadname\; (\interpvar : \tvar \to \Val \to \Prop)
  \ (\relvar : \tvar \to \tvar \to \bool) \eqdef{}&
  \MU (\recvar : \List\ \tvar \to \iProto).\\[-0.2em]
  &\hspace{-22em}
  \Lam \vec\var. \selectprot
    {(\sendprot {(\var : \tvar)\ (\val : \Val)} \val
       {\interpvar\ \var\ \val}
       {\recvar\ (\snoc{\var}{\vec\var})}) \ }
    {\ \listsortelemprottailname\ \interpvar\ \relvar\ \vec{\var}\ \nil} \\[0.1em]
\listsortelemprottailname\ (\interpvar : \tvar \to \Val \to \Prop)
  \ (\relvar : \tvar \to \tvar \to \bool) \eqdef{}&
  \MU (\recvar : \List\ \tvar \to \List\ \tvar \to \iProto). \\[-0.2em]
  &\hspace{-22em}
  \Lam \vec\var\ \vec\varB. \branchprotpropr
  {(\recvprot{(\varB : \tvar)\ (\val : \Val)} \val
     {(\All i < \listlength {\vec\varB}. \relvar\ \vec\varB_i\ \varB) * \interpvar\ \varB\ \val}
     {\recvar\ \vec\var\ (\snoc{\varB}{\vec\varB})}) \ }
  {\vec\var \perm \vec\varB}
  {\ \protend}
\end{align*}
%

\noindent
The protocol is split into two phases $\listsortelemprotheadname$ and
$\listsortelemprottailname$, mimicking the behaviour of the program.
The $\listsortelemprotheadname$ phase is indexed by the values $\vec\var$ that
have been sent so far.
The protocol describes that one can either send another value and proceed
recursively, or stop, which moves the protocol to the next phase.

The $\listsortelemprottailname$ phase is dependent on the list of values $\vec\var$
received in the first phase, and the list of values $\vec\varB$ returned so
far.
The condition $(\All i < \listlength {\vec\varB}. \relvar\ \vec\varB_i\ \varB)$
states that the received element is larger than any of the elements that have
previously been returned,
which maintains the invariant that the stream of received elements is sorted.
When the $\rightname$ flag is received $\vec\var \perm \vec\varB$ shows that the
received values $\vec\varB$ are a permutation of the ones $\vec\var$ that were sent,
making sure that all of the sent elements have been accounted for.

The top-level specification of the service and client are similar to the
specifications of the coarse-grained version of distributed merge sort:
\[
\begin{array}{c !{\quad} c}
\begin{array}{l}
  \hoareV
    {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
     \interp \chan {\protapp {\dual\listsortelemprotname} \prot}}
    {\listsortelemprotname\ \chan}
    {\interp \chan \prot}
\end{array}
  &
\begin{array}{l}
\hoareV
  {\cmpspecname\ \interpvar\ \relvar\ \cmpvar *
   \listrefI \interpvar \loc {\vec\var}}
  {\listsortelemclientname\ \cmpvar\ \loc}
  {
  \Exists \vec\varB.
   \listrefI \interpvar \loc {\vec\varB} *
   \sortedof {\vec\varB} {\vec\var} \relvar}
\end{array}
\end{array}
\]

\noindent
Proving these specifications requires one to pick appropriate specifications for
the auxiliary functions to capture the required invariants with regard to
sorting.
After having picked these specifications, the parts of the proofs that involve
communication are mostly straightforward, but require a number of trivial
auxiliary results
about sorting and permutations.
