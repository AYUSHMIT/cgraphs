\BOOKMARK [1][-]{section.1}{1. Introduction}{}% 1
\BOOKMARK [2][-]{subsection.1.1}{1.1. Message passing in concurrent separation logic}{section.1}% 2
\BOOKMARK [2][-]{subsection.1.2}{1.2. Actris 1.0: Dependent separation protocols}{section.1}% 3
\BOOKMARK [2][-]{subsection.1.3}{1.3. Actris 2.0: Subprotocols}{section.1}% 4
\BOOKMARK [2][-]{subsection.1.4}{1.4. Formal correspondence to session types}{section.1}% 5
\BOOKMARK [2][-]{subsection.1.5}{1.5. Contributions and outline}{section.1}% 6
\BOOKMARK [2][-]{subsection.1.6}{1.6. Differences from the conference version}{section.1}% 7
\BOOKMARK [1][-]{section.2}{2. A tour of Actris}{}% 8
\BOOKMARK [2][-]{subsection.2.1}{2.1. The Actris language}{section.2}% 9
\BOOKMARK [2][-]{figure.1}{2.2. The Actris logic}{section.2}% 10
\BOOKMARK [2][-]{subsection.2.3}{2.3. Basic protocols}{section.2}% 11
\BOOKMARK [2][-]{figure.3}{2.4. Transferring functions}{section.2}% 12
\BOOKMARK [2][-]{subsection.2.5}{2.5. Choice}{section.2}% 13
\BOOKMARK [2][-]{subsection.2.6}{2.6. Recursive protocols}{section.2}% 14
\BOOKMARK [2][-]{subsection.2.7}{2.7. Delegation}{section.2}% 15
\BOOKMARK [2][-]{subsection.2.8}{2.8. Dependent protocols}{section.2}% 16
\BOOKMARK [1][-]{section.3}{3. Subprotocols}{}% 17
\BOOKMARK [2][-]{subsection.3.1}{3.1. The subprotocol relation}{section.3}% 18
\BOOKMARK [2][-]{figure.8}{3.2. Swapping}{section.3}% 19
\BOOKMARK [2][-]{figure.9}{3.3. Minimal protocols}{section.3}% 20
\BOOKMARK [2][-]{subsection.3.4}{3.4. Subprotocols and recursion}{section.3}% 21
\BOOKMARK [1][-]{section.4}{4. Manifest sharing via locks}{}% 22
\BOOKMARK [2][-]{subsection.4.1}{4.1. Locks and ghost state}{section.4}% 23
\BOOKMARK [2][-]{subsection.4.2}{4.2. A distributed load-balancing mapper}{section.4}% 24
\BOOKMARK [1][-]{section.5}{5. Case study: map-reduce}{}% 25
\BOOKMARK [2][-]{subsection.5.1}{5.1. A functional specification of map-reduce}{section.5}% 26
\BOOKMARK [2][-]{subsection.5.2}{5.2. Implementation of map-reduce}{section.5}% 27
\BOOKMARK [2][-]{subsection.5.3}{5.3. Functional correctness of map-reduce}{section.5}% 28
\BOOKMARK [1][-]{section.6}{6. The model of Actris}{}% 29
\BOOKMARK [2][-]{subsection.6.1}{6.1. The model of dependent separation protocols}{section.6}% 30
\BOOKMARK [2][-]{subsection.6.2}{6.2. The model of the subprotocol relation}{section.6}% 31
\BOOKMARK [2][-]{subsection.6.3}{6.3. Protocol consistency}{section.6}% 32
\BOOKMARK [2][-]{subsection.6.4}{6.4. The Actris ghost theory}{section.6}% 33
\BOOKMARK [2][-]{subsection.6.5}{6.5. Semantics of channels}{section.6}% 34
\BOOKMARK [2][-]{subsection.6.6}{6.6. The model of channel ownership}{section.6}% 35
\BOOKMARK [2][-]{subsection.6.7}{6.7. Adequacy of Actris}{section.6}% 36
\BOOKMARK [2][-]{subsection.6.8}{6.8. Solving the recursive domain equation for protocols}{section.6}% 37
\BOOKMARK [1][-]{section.7}{7. Coq mechanisation}{}% 38
\BOOKMARK [2][-]{subsection.7.1}{7.1. Mechanisation effort}{section.7}% 39
\BOOKMARK [2][-]{subsection.7.2}{7.2. Tactic support for session type-based reasoning}{section.7}% 40
\BOOKMARK [2][-]{subsection.7.3}{7.3. Tactic support for subprotocols}{section.7}% 41
\BOOKMARK [1][-]{section.8}{8. Related work}{}% 42
\BOOKMARK [2][-]{subsection.8.1}{8.1. Message passing and separation logic}{section.8}% 43
\BOOKMARK [2][-]{subsection.8.2}{8.2. Separation logic and process calculi}{section.8}% 44
\BOOKMARK [2][-]{subsection.8.3}{8.3. Session types}{section.8}% 45
\BOOKMARK [2][-]{subsection.8.4}{8.4. Endpoint sharing}{section.8}% 46
\BOOKMARK [2][-]{subsection.8.5}{8.5. Verification of map-reduce}{section.8}% 47
\BOOKMARK [1][-]{section.9}{9. Conclusion and future work}{}% 48
\BOOKMARK [1][-]{section*.105}{Acknowledgments}{}% 49
\BOOKMARK [1][-]{section*.106}{References}{}% 50
