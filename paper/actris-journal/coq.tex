\section{Coq mechanisation}
\label{sec:coq}

\newcommand{\coqfig}{
\begin{figure}[t!]
\begin{tabular}{l|l|l}
\bf Component & \bf Sections & \bf $\sim$LOC \\ \hline\hline
The \lname model & \Cref{sec:protocol_model}--\Cref{sec:ghost_theory} & 1500 \\
Channel implementation and proof rules & \Cref{sec:semantics}--\Cref{sec:chan_own_model} & 350 \\
Tactics for symbolic execution & \Cref{sec:coq_prog_proof} & 500 \\
Utilities (linked lists, permutations, \etc) & n.a. &  450\\
Authoritative contribution ghost theory & \Cref{sec:integration} & 150 \\
Recursive domain equation theory solver & \Cref{sec:equation_solution} & 100 \\
Examples: & & \\
$\bullet$ Basic examples & \Cref{sec:intro} and~\Cref{sec:locks} & 400 \\
$\bullet$ Coarse-grained distributed merge sort & \Cref{sec:basics}--\Cref{sec:delegation} & 250 \\
$\bullet$ Fine-grained distributed merge sort & \Cref{sec:dependent} & 300 \\
$\bullet$ Mapper with swapping & \Cref{sec:subprotocol_swapping} & 400 \\
$\bullet$ List reversal & \Cref{sec:subprotocol_reuse} & 100 \\
$\bullet$ Distributed mapper & \Cref{sec:mapper} & 200 \\
$\bullet$ Distributed map-reduce & \Cref{sec:map_reduce} & 300 \\ \hline
\bf Total & & 5000 \\
\end{tabular}
\caption{Overview of the \lname Coq mechanisation.}
\label{fig:coq}
\end{figure}}

The definition of the \lname logic, its model, and the proofs of all examples
in this paper have been fully mechanised using the Coq proof
assistant~\cite{coq}.
In this section we will elaborate on the mechanisation effort
(\Cref{sec:coq_effort}), and go through the full proof of a message-passing program
(\Cref{sec:coq_prog_proof}) and a subprotocol relation (\Cref{sec:coq_subprot_proof})
showcasing the tactics for \lname.
During the section we display proofs and proof states taken directly from the Coq
mechanisation, which differs in notation from the paper as follows:
\begin{center}
  \begin{tabular}{l | l | l}
    & \textbf{Paper} & \textbf{Coq Mechanisation} \\\hline
    Send &
    $\sendprot{\var_1 \ldots \var_n}{\val}{\iprop}\prot$ &
    \lstinline|<! x_1 .. x_n> MSG v {{ P }}; prot| \\\hline
    Receive &
    $\recvprot{\var_1 \ldots \var_n}{\val}{\iprop}\prot$ &
    \lstinline|<? x_1 .. x_n> MSG v {{ P }}; prot| \\\hline
    End &
    $\protend$ &
    \lstinline|END| \\\hline
    Dual &
    $\dual{\prot}$&
    \lstinline|iProto_dual prot| \\\hline
    Literals &
    $\TT$, $5$, $\True$&
    \lstinline|#()|, \lstinline|#5|, \lstinline|#true| \\\hline
    \Binders &
    $\var$, $\varB$, $\varC, \_$&
    \lstinline|"x"|, \lstinline|"y"|, \lstinline|"z"|, \lstinline|<>| \\\hline
    Types &
    $1$, $\nat$, $\integer$&
    \lstinline|()|, \lstinline|nat|, \lstinline|Z|
  \end{tabular}
\end{center}

\subsection{Mechanisation effort}
\label{sec:coq_effort}

The mechanisation of Actris is built on top of the mechanisation of Iris
\cite{krebbers-ESOP2017,jung-ICFP06,jung-JFP2018}.
To carry out proofs in separation logic, we use the MoSeL Proof Mode
(formerly Iris Proof Mode)~\cite{krebbers-POPL2017,krebbers-PACMPL2018}, which
provides an embedded proof assistant for separation logic in Coq.
Building \lname on top of the Iris and MoSeL framework in Coq has a number of tangible
advantages:
\begin{itemize}
\item By defining channels on top of HeapLang, the default concurrent language
  shipped with Iris, we do not have to define a full programming language
  semantics, and can reuse all of the program libraries and Coq machinery,
  including the tactics for symbolic execution of non message-passing programs.
\item Since \lname is mechanised as an Iris library that provides
  support for the $\iProto$ type, the subprotocol relation
  $\subprot{\prot_1}{\prot_2}$, the $\interp \chan \prot$ connective, the
  various operations on protocols, and the proof rules as lemmas, we get all
  of the features of Iris for free,
  such as the ghost state mechanisms for reasoning about concurrency.
\item When proving the \lname proof rules, we can make use of the MoSeL Proof
  Mode to carry out proofs directly using separation logic, thus reasoning at
  a high-level of abstraction.
\item We can make use of the extendable nature of the MoSeL Proof Mode to
  define custom tactics for symbolic execution of message-passing programs.
\end{itemize}
These advantages made it possible to mechanise Actris, along with the examples of
the paper, with a small Coq development of a
total size of about 5000 lines of code (comments and whitespace included).
The line count of the different components are shown in \Cref{fig:coq}.
\coqfig

\subsection{Tactic support for session type-based reasoning}
\label{sec:coq_prog_proof}

To carry out interactive \lname's proof using symbolic execution, we follow the
methodology described in the original Iris Proof Mode paper \cite{krebbers-POPL2017},
which in particular means that the logic in Coq is presented in weakest precondition
style rather than using Hoare triples.
For handling $\langkw{send}$ or $\langkw{recv}$ we define the following tactics:
\begin{center}
\lstinline|wp_send (t1 .. tn)$\! $ with "[H1 .. Hn]"| \quad and \quad
\lstinline|wp_recv (y1 .. yn)$\! $ as "H"|.
\end{center}
These tactics roughly perform the following actions:
\begin{itemize}
\item Find a $\langkw{send}$ or $\langkw{recv}$ in evaluation position of the program
  under consideration.
\item Find a corresponding $\interp \chan \prot$ hypothesis in the separation
  logic context.
\item Normalise the protocol $\prot$ using the rules for duals, composition,
  recursion, and swapping so it has a
  $\sendprot {\xdots} \val \iprop \prot$ or
  $\recvprot {\xdots} \val \iprop \prot$ construct in its head position.
\item In case of \lstinline|wp_send|, instantiate the variables $\xdots$ using
  the terms \lstinline|(t1 .. tn)|, and create a goal for the proposition
  $\iprop$ with the hypotheses \lstinline|[H1 .. Hn]|.
  Hypotheses prefixed with $\mathtt{\$}$ will automatically be consumed to resolve a
  subgoal of $\iprop$ if possible.
  In case the terms \lstinline|(t1 .. tn)| are omitted, an attempt is made to
  determine these using unification.
\item In case of \lstinline|wp_recv|, introduce the variables $\xdots$ into the
  context by naming them \lstinline|(y1 .. yn)|, and create a hypothesis
  \lstinline|H| for $\iprop$.
\end{itemize}
The implementation of these tactics follows the approach by \cite{krebbers-POPL2017}.
The protocol normalisation is implemented via logic programming with type
classes.

As an example we will go through a proof of the following program:
\[
\begin{array}[t]{@{} l @{\ } l @{}}
\mathtt{prog\_ref\_swap\_loop} \eqdef{}
\Lam \TT. &
\LetNoIn {\chan} = \start
  (\Rec {\mathit{go}} \chan' =
    \begin{array}[t]{@{} l @{}}
      \Let l = {\recv \chan'} in \\
        l \leftarrow \deref l + 2; \\
      \send {\chan'} \TT;\ \mathit{go}\ \chan')\ \In \\
    \end{array}\\
& \Let {l_1} = \newref 18 in\\
& \Let {l_2} = \newref 20 in\\
& \send \chan l_1;\ \send \chan l_2; \\
& \recv \chan;\ \recv \chan;\\
& \deref l_1 + \deref l_2
\end{array}
\]
Here, the forked-off thread acts as a service that recursively receives locations,
adds 2 to their stored number, and then sends back a flag indicating that the
location has been updated.
The main thread, acting like a client, first allocates two new references,
to $18$ and $20$, respectively, which are both sent to the service
after which the update flags are received.
It finally dereferences the updated locations, and adds their values together,
thus returning $42$.
To verify this program, we use the following recursive protocol:
\[
  \mathtt{prot\_ref\_loop} \eqdef \MU (\recvar:\iProto).
  \sendprot{(\loc : \Loc) (\var : \integer)}{\loc}{\loc \mapsto \var}
  \recvprot{}{\TT}{\loc \mapsto \var+2}
  \recvar
\]
The service (in the forked-off thread) follows the (dual of) the protocol exactly,
while the main thread follows a weakened version, where the recursion is unfolded
twice, after which the second send has been swapped in front of the first receive,
allowing it to first send both values before receiving:
\[
  \begin{array}{@{} l @{\ } l}
  \mathtt{prot\_ref\_loop}
  \subprotop
  &\begin{array}[t]{@{} l}
  \sendprot{(\loc_1:\Loc)(\var_1:\integer)}{\loc_1}{\loc_1 \mapsto \var_1} \\
  \sendprot{(\loc_2:\Loc)(\var_2:\integer)}{\loc_2}{\loc_2 \mapsto \var_2} \\
  \recvprot{}{\TT}{\loc_1 \mapsto (\var_1+2)} \\
  \recvprot{}{\TT}{\loc_2 \mapsto (\var_2+2)}
  \mathtt{prot\_ref\_loop}
  \end{array}
  \end{array}
\]
The full Coq proof of the program is shown in \Cref{fig:program_proof}.
\begin{figure}
\begin{lstlisting}[numbers=left,xleftmargin=1cm,escapechar=|]
Lemma prog_ref_swap_loop_spec : ∀ Φ, Φ$\ $#42 -∗ WP prog_ref_swap_loop #() {{ Φ$\ $}}.
Proof.
  iIntros (Φ) "HΦ". wp_lam. |\label{line:proofsetup}|
  wp_apply (start_chan_spec prot_ref_loop); iIntros (c) "Hc". |\label{line:start}|
  - iLöb as "IH". wp_lam. |\label{line:forksetup}|
     wp_recv (l x) as "Hl". wp_load. wp_store. wp_send with "[$\$$Hl]". |\label{line:forkbody}|
     do 2 wp_pure _. by iApply "IH". |\label{line:forkclose}|
  - wp_alloc l1 as "Hl1". wp_alloc l2 as "Hl2". |\label{line:mainalloc}|
     wp_send with "[$\$$Hl1]". wp_send with "[$\$$Hl2]". |\label{line:mainsend}|
     wp_recv as "Hl1". wp_recv as "Hl2". |\label{line:mainrecv}|
     wp_load. wp_load. |\label{line:mainload}|
     wp_pures. by iApply "HΦ". |\label{line:mainclose}|
Qed.
\end{lstlisting}
\caption{Proof of message-passing program}
\label{fig:program_proof}
\end{figure}
The proved lemma is logically equivalent to the specification
$\hoare{\TRUE}{\mathtt{prog\_ref\_swap\_loop}\ ()}{ \Ret \val. \val = 42 }$,
but is presented in weakest precondition style as is common in Iris in Coq.
We start the proof on \lineref{line:proofsetup} by introducing the
postcondition continuation \lstinline{Φ}, and the hypothesis
\lstinline{HΦ : Φ$\ $#42},
and then evaluate the lambda expression with \lstinline{wp_lam}.
On \lineref{line:start} we apply the specification
\lstinline{start_chan_spec} for $\start{\_}$
by picking the expected protocol \lstinline{prot_ref_loop}.
This leaves us with two subgoals, separated by bullets \lstinline{-}:
one for the forked-off thread, and one for the main thread.

In the proof of the recursively-defined forked-off thread,
we use \lstinline{iLöb as "IH"} for \ruleref{Loeb} induction on \lineref{line:forksetup}.
This leaves us with the following intermediate proof state:
\begin{lstlisting}
"IH" : ▷ (c ↣$\ $iProto_dual prot_ref_loop -∗
              WP (rec: "go" "c'" :=
                      let: "l" := recv "c'" in "l" <- ! "l" + #2;;
                      send "c'" #();; "go" "c'") c {{ _, True }})
--------------------------------------□
"Hc" : c ↣$\ $iProto_dual prot_ref_loop
--------------------------------------∗
WP (rec: "go" "c'" :=
        let: "l" := recv "c'" in "l" <- ! "l" + #2;;
        send "c'" #();; "go" "c'") c {{ _, True }}
\end{lstlisting}
We now resolve the application of \lstinline{c} to the recursive function
with \lstinline{wp_lam}.
This lets us strip the later from the \ruleref{Loeb} induction hypothesis, as the program
has taken a step.
For brevity's sake we refer to the recursive program as \lstinline{prog_rec}, in the
following proof states.
\begin{lstlisting}
"IH" : c ↣$\ $iProto_dual prot_ref_loop -∗ WP prog_rec c {{ _, True }}
--------------------------------------□
"Hc" : c ↣$\ $iProto_dual prot_ref_loop
--------------------------------------∗
WP let: "l" := recv c in "l" <- ! "l" + #2;;
    send c #();; prog_rec c {{ _, True }}
\end{lstlisting}
On \lineref{line:forkbody} we resolve the proof of the body of the recursive function.
So far, the proof only used Iris's standard tactics, we now use the
\lname tactic for receive
\lstinline{wp_recv (l x)$\! $ as "Hl"}, to resolve the
receive in evaluation position, introducing the received \binders
\lstinline{l} and \lstinline{x},
along with the predicate of the protocol \lstinline{l ↦$\ $#x} naming it
\lstinline{Hl}.
To do so, the protocol is normalised, unfolding the recursive definition once,
as well as resolving the dualisation of the head,
turning it into a receive as expected.
This leads to the following proof state:
\begin{lstlisting}
"IH" : c ↣$\ $iProto_dual prot_ref_loop -∗ WP prog_rec c {{ _, True }}
--------------------------------------□
"Hl" : l ↦$\ $#x
"Hc" : c ↣$\ $iProto_dual (<?> MSG #() {{ l ↦$\ $#(x + 2) }}; prot_ref_loop)
--------------------------------------∗
WP let: "l" := #l in "l" <- ! "l" + #2;; send c #();; prog_rec c {{ _, True }}
\end{lstlisting}
We then use \lstinline{wp_load} and \lstinline{wp_store} to resolve the
dereferencing and updating of the location:
\begin{lstlisting}
"IH" : c ↣$\ $iProto_dual prot_ref_loop -∗ WP prog_rec c {{ _, True }}
--------------------------------------□
"Hl" : l ↦$\ $#(x + 2)
"Hc" : c ↣$\ $iProto_dual (<?> MSG #() {{ l ↦$\ $#(x + 2) }}; prot_ref_loop)
--------------------------------------∗
WP send c #();; prog_rec c  {{ _, True }}
\end{lstlisting}
We then use \lname's tactic \lstinline{wp_send with "[$\$$Hl]"} to resolve the
send operation in evaluation
position, by giving up the ownership of \lstinline{"Hl"}.
Again, the protocol is automatically normalised by resolving the dualisation of the receive
($\RECV$) to obtain the send ($\SEND$) as expected.

We finally close the proof of the forked-off thread on \lineref{line:forkclose}.
We first take two pure evaluation steps revolving the sequencing of operations with
\lstinline{do 2 wp_pure _} to reach the recursive call.
This results in the proof state:
\begin{lstlisting}
"IH" : c ↣$\ $iProto_dual prot_ref_loop -∗ WP prog_rec c {{ _, True }}
--------------------------------------□
"Hc" : c ↣$\ $iProto_dual prot_ref_loop
--------------------------------------∗
WP prog_rec c {{ _, True }}
\end{lstlisting}
We then use \lstinline{by iApply "IH"} to close the proof by using the
\ruleref{Loeb} induction hypothesis.

The proof of the main thread follows similarly.
On \lineref{line:mainalloc} we use \lstinline{wp_alloc l1 as "Hl1"} and
\lstinline{wp_alloc l2 as "Hl2"}, to resolve the allocations of the new locations,
binding the logical variables of the locations to \lstinline{l1} and \lstinline{l2},
and adding hypotheses \lstinline{"Hl1"} and \lstinline{"Hl2"} for ownership
of these locations to the separation logic proof context.
The proof state is then:
\begin{lstlisting}
"HΦ" : Φ$\ $#42
"Hc" : c ↣$\ $prot_ref_loop
"Hl1" : l1 ↦$\ $#18
"Hl2" : l2 ↦$\ $#20
--------------------------------------∗
WP send c #l1;; send c #l2;; recv c;; recv c;; ! #l1 + ! #l2 {{ v, Φ$\ $v }}
\end{lstlisting}
On \lineref{line:mainsend},
we then resolve the first send operation with \lname's tactic
\lstinline{wp_send with "[$\$$Hl1]"}, by giving up
ownership of the location \lstinline|l1|.
Here, the protocol is normalised by unfolding the recursive definition, after which the
head symbol is a send ($\SEND$) as expected.
The resulting proof state is as follows:
\begin{lstlisting}
"HΦ" : Φ$\ $#42
"Hl2" : l2 ↦$\ $#20
"Hc" : c ↣$\ $(<?> MSG #() {{ l1 ↦$\ $#(18 + 2) }}; prot_ref_loop)
--------------------------------------∗
WP send c #l2;; recv c;; recv c;; ! #l1 + ! #l2 {{ v, Φ$\ $v }}
\end{lstlisting}
To resolve the second send operation, we need to weaken the protocol using swapping
(rule \ruleref{SP-swap'}), which is taken care of automatically by \lname's tactic
\lstinline{wp_send with "[$\$$Hl2]"}.
The normalisation detects that the protocol has a
receive ($\RECV$) as a head symbol, and therefore attempts swapping.
To do so it steps ahead of the receive ($\RECV$), and unfolds the recursive definition,
which results in a send ($\SEND$) as the first symbol after the head.
It then detects that there are no dependencies between the two, and can thus apply
the swapping rule \ruleref{SP-swap'}, moving the send ($\SEND$) ahead of the
receive ($\RECV$).
With the head symbol now being a send ($\SEND$), the symbolic execution continues as normal,
resulting in the proof state:
\begin{lstlisting}
"HΦ" : Φ$\ $#42
"Hc" : c ↣$\ $(<?> MSG #() {{ l1 ↦$\ $#(18 + 2) }};
                  <?> MSG #() {{ l2 ↦$\ $#(20 + 2) }}; prot_ref_loop)
--------------------------------------∗
WP recv c;; recv c;; ! #l1 + ! #l2 {{ v, Φ$\ $v }}
\end{lstlisting}
On \lineref{line:mainrecv} we then proceed as expected with \lstinline{wp_recv as "Hl1"}
and \lstinline{wp_recv as "Hl2"}, to resolve the receive operations, giving us back the updated
point-to resources:
\begin{lstlisting}
"HΦ" : Φ$\ $#42
"Hl1" : l1 ↦$\ $#(18 + 2)
"Hl2" : l2 ↦$\ $#(20 + 2)
"Hc" : c ↣$\ $prot_ref_loop
--------------------------------------∗
WP ! #l1 + ! #l2 {{ v, Φ$\ $v }}
\end{lstlisting}
At \lineref{line:mainload} we then continue by using \lstinline{wp_load} twice to
dereference the reacquired and updated locations, and then use trivial symbolic execution
to resolve the remaining computations.
On \lineref{line:mainclose} we finally close the proof with the continuation
hypothesis \lstinline{by iApply "HΦ"}.

\subsection{Tactic support for subprotocols}
\label{sec:coq_subprot_proof}

While the \lname tactics automatically apply the subprotocol rules during
symbolic execution, as shown in \Cref{sec:coq_prog_proof},
we sometimes want to prove subprotocol relations as explicit lemmas.
We have tactic support for such proofs as well, which is integrated with the
existing MoSeL tactics
\lstinline{iIntros}, \lstinline{iExists}, \lstinline{iFrame}, \lstinline{iModIntro},
and \lstinline{iSplitL/iSplitR} by automatically using the subprotocol rules to
turn the goal into a goal where the regular Iris tactics apply.
\begin{itemize}
\item \lstinline{iIntros (x1 .. xn)$\! $ "H1 .. Hm"}
  transforms the subprotocol goal to
  begin with \lstinline{n} universal quantification and \lstinline{m} implications, using the rules
  \ruleref{SP-send-intro} and \ruleref{SP-recv-intro},
  and then introduces the quantifiers (naming them \lstinline{x1 .. xn}) into the
  Coq context, and the hypotheses (naming them \lstinline{H1 .. Hm}) into the
  separation logic context.
\item \lstinline{iExists (t1 .. tn)} transforms the subprotocol goal to start with
  \lstinline{n} existential quantifiers, using the
  \ruleref{SP-send-elim} and \ruleref{SP-recv-elim} rules,
  and then instantiates these quantifiers with the terms \lstinline{t1 .. tn} specified by the pattern.
\item \lstinline{iFrame "H"} transforms the subprotocol goal into a separating
  conjunction between the payload predicates of the head symbols of either
  protocol, using the rules
  \ruleref{SP-send-elim} and \ruleref{SP-recv-elim},
  and then tries to solve the payload predicate subgoal using \lstinline|"H"|.
\item \lstinline{iModIntro} transforms the subprotocol goal into a
  goal starting with a later modality ($\later$), using the rules
  \ruleref{SP-send-mono} and \ruleref{SP-recv-mono},
  and then introduces that later by stripping off a later from any hypothesis
  in the separation logic context.
\item \lstinline{iSplitL/iSplitR "H1 .. Hn"} transforms the subprotocol goal into a
  separating conjunction between the payload predicates of the head symbols of either
  protocol, using the rules
  \ruleref{SP-send-elim} and \ruleref{SP-recv-elim},
  and then creates two subgoals.
  For \lstinline{iSplitL} the left subgoal is given the hypotheses
  \lstinline{H1 .. Hn} from the separation logic context,
  while the right subgoal is given any remaining hypotheses, and \viceversa for
  \lstinline{iSplitR}.
\end{itemize}
The extensions of these tactics are implemented by defining custom type class
instances that hook into the existing MoSeL tactics as described in \cite{krebbers-POPL2017}.

To demonstrate these tactics, we will go through a proof of the subprotocol relation
for the list reversing service presented in \Cref{sec:subprotocol_reuse}:
\[
  \begin{array}{@{} l @{} l @{}}
  &\sendprot{(\loc:\Loc)(\vec{\val}:\List\ \Val)}{\loc}{\listref{\loc}{\vec{\val}}}
  \recvprot{}{\TT}{\listref{\loc}{\listrev{\vec{\val}}}}
  \protend\\
  \subprotop{} &
  \sendprot{(\loc:\Loc)(\vec{\var}:\List\ \tvar)}{\loc}
  {\listrefI{\interpvar_\tvar}{\loc}{\vec{\var}}}
  \recvprot{}{\TT}
  {\listrefI{\interpvar_\tvar}{\loc}{\listrev{\vec{\var}}}}
  \protend
  \end{array}
\]
Recall that the following conversion between
the list representation predicate with payload $\listrefI{\interpvar_\tvar}{\loc}{\vec{\var}}$
and one without payload $\listref{\loc}{\vec{\val}}$ holds:
\[
  \mathit{Hlr} \quad : \quad
  \textstyle
  \listrefI{\interpvar_\tvar}{\loc}{\vec{\var}} \ \wandIff \
  (\Exists \vec{\val}.
  \listref{\loc}{\vec{\val}} \ast
  \Sep_{(\var,\val) \in (\vec{\var},\vec{\val})}.
  \interpvar_\tvar\ \var\ \val)
\]
The full Coq proof is shown in \Cref{fig:subprot_proof}.
\begin{figure}
\begin{lstlisting}[numbers=left,xleftmargin=1cm,escapechar=|]
Lemma list_rev_subprot :
  ⊢$\ $(<! (l : loc) (vs : list val)> MSG #l {{ llist l vs }};
      <?> MSG #() {{ llist internal_eq l (reverse vs) }}; END) ⊑
     (<! (l : loc) (xs : list T)> MSG #l {{ llistI IT l xs }};
      <?> MSG #() {{ llistI IT l (reverse xs) }}; END).
Proof.
  iIntros (l xs) "Hl". |\label{line:sp_send_intro}|
  iDestruct (Hlr with "Hl") as (vs) "[Hl HIT]". |\label{line:sp_lr_split}|
  iExists l, vs. iFrame "Hl". |\label{line:sp_send_elim}|
  iModIntro.|\label{line:sp_send_mono}| iIntros "Hl". |\label{line:sp_recv_intro}|
  iSplitL. |\label{line:sp_recv_elim}|
  { rewrite big_sepL2_reverse_2. iApply Hlr. |\label{line:sp_sg_11}|
    iExists (reverse vs). iFrame "Hl HIT". } |\label{line:sp_sg_12}|
  done. |\label{line:sp_sg_2}|
Qed.
\end{lstlisting}
\caption{Proof of subprotocol relation}
\label{fig:subprot_proof}
\end{figure}
On \lineref{line:sp_send_intro} we start the proof by introducing the
\binders \lstinline{l}, \lstinline{xs} and the payload
\lstinline{llistI IT l xs} of the weaker protocol with the tactic
\lstinline{iIntros (l xs)$\! $ "Hl"}.
This tactic will implicitly apply the rule \ruleref{SP-send-intro}, so the goal
starts with a universal quantification
\lstinline{∀ (l : loc) (xs : list T). llistI IT l xs -∗ ...},
which is then introduced based on the regular Iris introduction pattern.
This gives us:
\begin{lstlisting}
"Hl" : llistI IT l vs
--------------------------------------∗
(<! (l : loc) (vs : list val)> MSG #l {{ llist l vs }};
 <?> MSG #() {{ llist l (reverse vs) }}; END) ⊑
(<!> MSG #l; <?> MSG #() {{ llistI IT l (reverse xs) }}; END)
\end{lstlisting}
To obtain the payload predicate expected by the stronger protocol,
we use the lemma $\mathtt{Hlr}$,
to derive \lstinline{llist l vs} and
\lstinline{[∗ list] x;v ∈$\ $xs;vs, IT x v} from
\lstinline{llistI l xs} with the tactic
\lstinline{iDestruct (Hlr with "Hl")$\! $ as (vs) "[Hl HIT]"} on
\lineref{line:sp_lr_split}.
The resulting proof state is:
\begin{lstlisting}
"Hl" : llist l vs
"HIT" : [∗ list] x;v ∈$\ $xs;vs, IT x v
--------------------------------------∗
(<! (l : loc) (vs : list val)> MSG #l {{ llist l vs }};
 <?> MSG #() {{ llist l (reverse vs) }}; END) ⊑
(<!> MSG #l; <?> MSG #() {{ llistI IT l (reverse xs) }}; END)
\end{lstlisting}
At \lineref{line:sp_send_elim} we
instantiate the \binders of the stronger protocol with the
\binders \lstinline{l} and \lstinline{vs} using \lstinline{iExists l, vs}.
This will implicitly apply the rule \ruleref{SP-send-elim}, which makes the goal
start with \lstinline{∃ (l : loc)$\! $ (vs : list val)}, so the existentials
can be instantiated as usual.
To resolve the payload predicate obligation \lstinline{llist l vs}, we use
\lstinline{iFrame "Hl"}.
This uses the \ruleref{SP-send-elim} to turn the goal into
\lstinline{llist l vs ∗$\ $...}, where the left subgoal is resolved using
\lstinline{"Hl"}.
We then have the following remaining proof state:
\begin{lstlisting}
"HIT" : [∗ list] x;v ∈$\ $xs;vs, IT x v
--------------------------------------∗
(<!> MSG #l; <?> MSG #() {{ llist l (reverse vs) }}; END) ⊑
(<!> MSG #l; <?> MSG #() {{ llistI IT l (reverse xs) }}; END)
\end{lstlisting}
As the head symbols of both protocols are sends ($\SEND$) with no \binders or
payload predicates, we use \lstinline{iModIntro}
on \lineref{line:sp_send_mono}, which first applies
\ruleref{SP-send-mono} to step over the sends, and then
introduces the later modality ($\later$).
This gives us the proof state:
\begin{lstlisting}
"HIT" : [∗ list] x;v ∈$\ $xs;vs, IT x v
--------------------------------------∗
(<?> MSG #() {{ llist l (reverse vs) }}; END) ⊑
(<?> MSG #() {{ llistI IT l (reverse xs) }}; END)
\end{lstlisting}
On \lineref{line:sp_recv_intro}, similarly to before, we use
\lstinline{iIntros "Hl"}, to introduce the payload predicate,
but this time we do it for the stronger protocol,
as dictated by \ruleref{SP-recv-intro}:
\begin{lstlisting}
"HIT" : [∗ list] x;v ∈$\ $xs;vs, IT x v
"Hl" : llist l (reverse vs)
--------------------------------------∗
(<?> MSG #() ; END) ⊑
(<?> MSG #() {{ llistI IT l (reverse xs) }}; END)
\end{lstlisting}
To resolve the payload predicate of the weaker protocol, we use
\lstinline{iSplitL "Hl HIT"} on \lineref{line:sp_recv_elim}, that first use
\ruleref{SP-recv-elim}, to turn the goal into
\lstinline{llistI IT l (reverse xs)$\ $∗$\ $...}, and then use the goal splitting pattern
of Iris, to give us two subgoals, where we use the hypotheses \lstinline{"Hl"} and
\lstinline{"HIT"} in the left subgoal.
The first subgoal is then:
\begin{lstlisting}
"HIT" : [∗ list] x;v ∈$\ $xs;vs, IT x v
"Hl" : llist l (reverse vs)
--------------------------------------∗
llistI IT l (reverse xs)
\end{lstlisting}
On \lineref{line:sp_sg_11}, we first use the lemma \lstinline{Hlr}
in the right-to-left
direction, and then rewrite the hypothesis \lstinline{"HIT"} using a
lemma from the Iris library with \lstinline{rewrite big_sepL2_reverse_2}.
We do this to obtain \lstinline{[∗ list] x;v ∈$\ $reverse xs;reverse vs, IT x v},
in order to match the proof goal.
This gives the proof obligation:
\begin{lstlisting}
"HIT" : [∗ list] x;v ∈$\ $reverse xs;reverse vs, IT x v
"Hl" : llist l (reverse vs)
--------------------------------------∗
∃$\ $vs : list val, llist l vs ∗$\ $([∗ list] x;v ∈ reverse xs;vs, IT x v)
\end{lstlisting}
We finally close the proof on \lineref{line:sp_sg_12}
with \lstinline{iExists (reverse vs)}, followed by
\lstinline{iFrame "Hl HIT"}, as the goal matches the hypotheses exactly,
when picking \lstinline{reverse vs} as the existential quantification.
We then move on to the second subgoal:
\begin{lstlisting}
--------------------------------------∗
(<?> MSG #(); END) ⊑$\ $(<?> MSG #(); END)
\end{lstlisting}
We resolve this subgoal, on \lineref{line:sp_sg_2},
with the tactic \lstinline{done},
which tries to close the proof, by automatically applying
\ruleref{SP-refl}.
