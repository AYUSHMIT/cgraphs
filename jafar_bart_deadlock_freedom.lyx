#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Jafar & Bart's deadlock freedom
\end_layout

\begin_layout Subsection*
Deadlock freedom voor locks
\end_layout

\begin_layout Standard
Het idee is dat je een ordening op je locks hebt door bij het maken van
 een lock een getal te kiezen.
 Een resource is een set van locks die aangeeft welke locks op dat moment
 gelocked zijn.
 Bij het locken stop je de lock in de set, en bij het unlocken verwijder
 je het weer.
 Verder mag je alleen locken als het getal van je lock kleiner is dan de
 getallen van de locks die op dat moment in je set zitten.
 Bij fork splits je je set in twee delen, en eis je van de geforkte thread
 dat hij alles in zijn set unlockt.
\end_layout

\begin_layout Standard
Dit voorkomt deadlocks.
 Het simpelste voorbeeld is een thread die twee keer dezelfde lock probeert
 te locken.
 De eerste keer locken gaat lukken, maar dan komt die lock in je multiset,
 dus dan kun je hem niet nog een keer locken omdat je alleen locks mag locken
 met getal kleiner dan alles wat in je multiset zit.
 Verder voorkomt dit dat twee threads een set van locks allebei in een andere
 volgorde locken, want je kunt locks alleen in volgorde van hoog getal naar
 laag getal locken.
\end_layout

\begin_layout Standard
In het algemeen kan de thread die op dit moment de laagste lock met getal
 n heeft altijd voortgang boeken.
 Stel namelijk dat die thread op een lock m aan het wachten is.
 Het getal m kan niet >= n zijn, want op dat soort locks mag die thread
 niet wachten omdat n in zijn multiset zit.
 Het getal m kan ook niet <n zijn, want dat betekent dat een andere thread
 de m<n lock heeft, en dan was dit niet de thread met de laagste lock.
 Dit betekent dat er in ieder geval één thread vooruit kan.
\end_layout

\begin_layout Subsection*
Deadlock freedom voor channels
\end_layout

\begin_layout Standard
Voor channels gebruiken we een multiset van channels, want we kunnen meerdere
 berichten achter elkaar op een channel sturen.
 Bij het sturen halen we het channel 1x uit de multiset.
 We hebben naast de multiset ook credit(ch) van een channel.
 Dit geeft de permissie om van het channel te lezen.
 We kunnen zo'n credit maken door ook de obligatie om op het channel te
 sturen in de multiset te stoppen.
 We mogen alleen van een channel lezen als het getal van het channel lager
 is dan alles wat in de multiset zit.
\end_layout

\begin_layout Subsection*
Deadlock freedom voor monitors
\end_layout

\begin_layout Standard
Iedere lock kan een aantal geassocieerde condition variables hebben.
 Iedere condition variable heeft ook een getal dat zijn plaats in de order
 bepaalt.
 De lock houdt per condition variable bij hoe veel threads er op wachten
 en hoe veel threads de obligatie hebben om hem te signallen.
 Een thread can die obligaties ophogen door zelf een obligatie aan te gaan.
 Een thread kan ook een obligatie weghalen door het corresponderende aantal
 obligaties in de lock met één te verlagen, maar dit kan alleen als (1)
 het aantal wachtenden 0 is of (2) het aantal obligaties na het verlagen
 niet 0 is.
\end_layout

\end_body
\end_document
