Formalised proof of deadlock freedom for classical session types
----------------------------------------------------------------
Make detailed plan.

Look at the lemma's about trees and try to understand what kind of tree manipulations
result from steps in the operational semantics.

Introduction:
- Problem with existing proofs.
- Which feature can be added to our system to strengthen our claim over existing work.
- Keep track of references to Wadler/Stephanie/etc.
- Why is the connectivity graph original? Why undirected? (classic/intuitionistic)

Contributions:
- Connectivity graph idea
- Proof of deadlock freedom for a linear lambda calculus with channels, 
  with low level semantics
  (Wadler's proof is not detailed, uses cut elimination so doesn't support nontermination)
- Mechanised in Coq
Check:
1. Whether Wadler's semantics is asynchronous or not, and also for Fabrizio's
2. Recursion on the term level

Think about:
- For meeting with Herman: what do I want him to do, what do I want Robbert to do?
  Good way to mentor me?
- Seminar talk end of october (depends on POPL reviews?)
- Think about plan for ESOP
- Think about extensions that lead to a paper


Deadlock freedom for channels in Iris
-------------------------------------
Contributions:
A) Low-level logic for deadlock freedom for a language with built-in channels
B) Actris-like logic with deadlock freedom



[[Actris on Iron: linear channel logic
---------------------------------
Resource leak freedom
Required for deadlock freedom
(Thread local resources)]]



Deadlock freedom for session types in Iris
------------------------------------------
A) Logical relations model for session types
B) Verification of unsafe code



General framework for deadlock freedom in Iris
----------------------------------------------
