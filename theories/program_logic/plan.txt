●◯

Define:
=======

l ↦ o := own γ1 (◯{l := to_agree o})
Obs i O := own γ2 {◯{i := to_excl O}}
lock l R := own γ3 {◯{l := to_agree R}}
locked l := own γ4 {◯{l := to_excl true}}
state_interp σ es :=
    exists L : gmap loc (nat * iProp * bool)
           T : list (gmap nat * option loc),
      own γ1 (● f1 L ) * own γ2 (● f2 T) * own γ3 (● f3 L) * own γ4 (● f4 T) *
      [* list] l↦(_,R,b)∈L, l↦#b * if b then True else R *
      [* list] i↦e;(o,l)∈es;T, W σ e l * l < O

W σ e l := match l with
    | None => ¬ waiting e σ
    | Some l => exists K, e = fill K (WAS l #false #true)

M1 := auth (gmap loc (agree nat))
M2 := auth (gmap nat (excl (gmap nat)))
M3 := auth (gmap loc (agree iProp))
M4 := auth (gmap loc (excl bool))

WP rules:
=========

Obs (O + O') -* (forall j, Obs j O -* WP j e { Obs j empty }) -* Obs i O' -* Φ ()
=================================================================================
WP i fork e { Φ }


R    (forall l, lock l R * l↦o -* Φ l)
======================================
WP i newlock () { Φ }

lock l R * l↦o * Obs i O * o < O * (Obs i (O + {o}) * R * locked l -* Φ ())
===========================================================================
WP i acquire l { Φ }


lock l R * l↦o * locked l * R * Obs i O * (Obs i (O - {o}) -* Φ ())
===================================================================
WP i release l { Φ }


Questions:
==========

Merge lock l R * l↦o into lock l R o?
Merge M1,M3 into M' := auth (gmap loc (agree (nat * iProp)))?
